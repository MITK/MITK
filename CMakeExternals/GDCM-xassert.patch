diff --git a/Source/Common/gdcmException.h b/../Source/Common/gdcmException.h
index 8a31a3d..99ffb42 100644
--- a/Source/Common/gdcmException.h
+++ b/Source/Common/gdcmException.h
@@ -98,6 +98,8 @@ private:
 
 } // end namespace gdcm
 
+#define xassert(x) if(x){}else throw Exception("Assertion `" #x "' failed.", __FILE__, __LINE__)
+
 // Undo warning suppression.
 #if defined(__clang__) && defined(__has_warning)
 # if __has_warning("-Wdeprecated")
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmAttribute.h b/Source/DataStructureAndEncodingDefinition/gdcmAttribute.h
index af4d2a2..de1f621 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmAttribute.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmAttribute.h
@@ -125,7 +125,7 @@ public:
 
   // copy:
   //ArrayType GetValue(unsigned int idx = 0) {
-  //  assert( idx < GetNumberOfValues() );
+  //  xassert( idx < GetNumberOfValues() );
   //  return Internal[idx];
   //}
   //ArrayType operator[] (unsigned int idx) {
@@ -152,7 +152,7 @@ public:
     }
 
   ArrayType &GetValue(unsigned int idx = 0) {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     return Internal[idx];
   }
   ArrayType & operator[] (unsigned int idx) {
@@ -160,18 +160,18 @@ public:
   }
   // const reference
   ArrayType const &GetValue(unsigned int idx = 0) const {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     return Internal[idx];
   }
   ArrayType const & operator[] (unsigned int idx) const {
     return GetValue(idx);
   }
   void SetValue(ArrayType v, unsigned int idx = 0) {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     Internal[idx] = v;
   }
   void SetValues(const ArrayType* array, unsigned int numel = VMType ) {
-    assert( array && numel && numel == GetNumberOfValues() );
+    xassert( array && numel && numel == GetNumberOfValues() );
     // std::copy is smarted than a memcpy, and will call memcpy when POD type
     std::copy(array, array+numel, Internal);
   }
@@ -187,7 +187,7 @@ public:
     EncodingImplementation<VRToEncoding<TVR>::Mode>::Write(Internal,
       GetNumberOfValues(),os);
     ret.SetVR( GetVR() );
-    assert( ret.GetVR() != VR::SQ );
+    xassert( ret.GetVR() != VR::SQ );
     if( (VR::VRType)VRToEncoding<TVR>::Mode == VR::VRASCII )
       {
       if( GetVR() != VR::UI )
@@ -205,9 +205,9 @@ public:
 
   void SetFromDataElement(DataElement const &de) {
     // This is kind of hackish but since I do not generate other element than the first one: 0x6000 I should be ok:
-    assert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000 || GetTag().GetGroup() == 0x5000 );
-    assert( GetVR() != VR::INVALID );
-    assert( GetVR().Compatible( de.GetVR() ) || de.GetVR() == VR::INVALID ); // In case of VR::INVALID cannot use the & operator
+    xassert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000 || GetTag().GetGroup() == 0x5000 );
+    xassert( GetVR() != VR::INVALID );
+    xassert( GetVR().Compatible( de.GetVR() ) || de.GetVR() == VR::INVALID ); // In case of VR::INVALID cannot use the & operator
     if( de.IsEmpty() ) return;
     const ByteValue *bv = de.GetByteValue();
 #ifdef GDCM_WORDS_BIGENDIAN
@@ -236,7 +236,7 @@ public:
 protected:
   void SetByteValueNoSwap(const ByteValue *bv) {
     if( !bv ) return; // That would be bad...
-    assert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
+    xassert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
     //if( VRToEncoding<TVR>::Mode == VR::VRBINARY )
     //  {
     //  // always do a copy !
@@ -253,7 +253,7 @@ protected:
   }
   void SetByteValue(const ByteValue *bv) {
     if( !bv ) return; // That would be bad...
-    assert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
+    xassert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
     //if( VRToEncoding<TVR>::Mode == VR::VRBINARY )
     //  {
     //  // always do a copy !
@@ -274,7 +274,7 @@ protected:
     const uint16_t cref[] = { Group, Element };
     uint16_t c[2];
     _is.read((char*)&c, sizeof(c));
-    assert( c[0] == cref[0] && c[1] == cref[1] );
+    xassert( c[0] == cref[0] && c[1] == cref[1] );
     char vr[2];
     _is.read(vr, 2); // Check consistency ?
     const uint32_t lref = GetLength() * sizeof( typename VRToType<TVR>::Type );
@@ -357,7 +357,7 @@ public:
   }
   // copy:
   //ArrayType GetValue(unsigned int idx = 0) {
-  //  assert( idx < GetNumberOfValues() );
+  //  xassert( idx < GetNumberOfValues() );
   //  return Internal[idx];
   //}
   //ArrayType operator[] (unsigned int idx) {
@@ -384,7 +384,7 @@ public:
     }
 
   ArrayType &GetValue() {
-//    assert( idx < GetNumberOfValues() );
+//    xassert( idx < GetNumberOfValues() );
     return Internal;
   }
 //  ArrayType & operator[] (unsigned int idx) {
@@ -392,18 +392,18 @@ public:
 //  }
   // const reference
   ArrayType const &GetValue() const {
-    //assert( idx < GetNumberOfValues() );
+    //xassert( idx < GetNumberOfValues() );
     return Internal;
   }
   //ArrayType const & operator[] () const {
   //  return GetValue();
   //}
   void SetValue(ArrayType v) {
-//    assert( idx < GetNumberOfValues() );
+//    xassert( idx < GetNumberOfValues() );
     Internal = v;
   }
 /*  void SetValues(const ArrayType* array, unsigned int numel = VMType ) {
-    assert( array && numel && numel == GetNumberOfValues() );
+    xassert( array && numel && numel == GetNumberOfValues() );
     // std::copy is smarted than a memcpy, and will call memcpy when POD type
     std::copy(array, array+numel, Internal);
   }
@@ -422,7 +422,7 @@ public:
     EncodingImplementation<VRToEncoding<TVR>::Mode>::Write(&Internal,
       GetNumberOfValues(),os);
     ret.SetVR( GetVR() );
-    assert( ret.GetVR() != VR::SQ );
+    xassert( ret.GetVR() != VR::SQ );
     if( (VR::VRType)VRToEncoding<TVR>::Mode == VR::VRASCII )
       {
       if( GetVR() != VR::UI )
@@ -440,9 +440,9 @@ public:
 
   void SetFromDataElement(DataElement const &de) {
     // This is kind of hackish but since I do not generate other element than the first one: 0x6000 I should be ok:
-    assert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000 || GetTag().GetGroup() == 0x5000 );
-    assert( GetVR() != VR::INVALID );
-    assert( GetVR().Compatible( de.GetVR() ) || de.GetVR() == VR::INVALID ); // In case of VR::INVALID cannot use the & operator
+    xassert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000 || GetTag().GetGroup() == 0x5000 );
+    xassert( GetVR() != VR::INVALID );
+    xassert( GetVR().Compatible( de.GetVR() ) || de.GetVR() == VR::INVALID ); // In case of VR::INVALID cannot use the & operator
     if( de.IsEmpty() ) return;
     const ByteValue *bv = de.GetByteValue();
 #ifdef GDCM_WORDS_BIGENDIAN
@@ -471,7 +471,7 @@ public:
 protected:
   void SetByteValueNoSwap(const ByteValue *bv) {
     if( !bv ) return; // That would be bad...
-    assert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
+    xassert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
     //if( VRToEncoding<TVR>::Mode == VR::VRBINARY )
     //  {
     //  // always do a copy !
@@ -488,7 +488,7 @@ protected:
   }
   void SetByteValue(const ByteValue *bv) {
     if( !bv ) return; // That would be bad...
-    assert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
+    xassert( bv->GetPointer() && bv->GetLength() ); // [123]C element can be empty
     //if( VRToEncoding<TVR>::Mode == VR::VRBINARY )
     //  {
     //  // always do a copy !
@@ -509,7 +509,7 @@ protected:
     const uint16_t cref[] = { Group, Element };
     uint16_t c[2];
     _is.read((char*)&c, sizeof(c));
-    assert( c[0] == cref[0] && c[1] == cref[1] );
+    xassert( c[0] == cref[0] && c[1] == cref[1] );
     char vr[2];
     _is.read(vr, 2); // Check consistency ?
     const uint32_t lref = GetLength() * sizeof( typename VRToType<TVR>::Type );
@@ -598,7 +598,7 @@ public:
       os << "," << Internal[i];
     }
   ArrayType &GetValue(unsigned int idx = 0) {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     return Internal[idx];
   }
   ArrayType &operator[] (unsigned int idx) {
@@ -606,14 +606,14 @@ public:
   }
   // const reference
   ArrayType const &GetValue(unsigned int idx = 0) const {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     return Internal[idx];
   }
   ArrayType const & operator[] (unsigned int idx) const {
     return GetValue(idx);
   }
   void SetValue(unsigned int idx, ArrayType v) {
-    assert( idx < GetNumberOfValues() );
+    xassert( idx < GetNumberOfValues() );
     Internal[idx] = v;
   }
   void SetValue(ArrayType v) { SetValue(0, v); }
@@ -628,10 +628,10 @@ public:
       }
     Own = own;
     Length = numel;
-    assert( Internal == 0 );
+    xassert( Internal == 0 );
     if( own ) // make a copy:
       {
-      assert( /*array &&*/ numel );
+      xassert( /*array &&*/ numel );
       Internal = new ArrayType[numel];
       if( array && numel )
         std::copy(array, array+numel, Internal);
@@ -641,7 +641,7 @@ public:
       Internal = const_cast<ArrayType*>(array);
       }
     // postcondition
-    assert( numel == GetNumberOfValues() );
+    xassert( numel == GetNumberOfValues() );
     }
 
   DataElement GetAsDataElement() const {
@@ -663,17 +663,17 @@ public:
         }
       }
     ret.SetVR( GetVR() );
-    assert( ret.GetVR() != VR::SQ );
+    xassert( ret.GetVR() != VR::SQ );
     VL::Type osStrSize = (VL::Type) os.str().size();
     ret.SetByteValue( os.str().c_str(), osStrSize);
     return ret;
   }
   void SetFromDataElement(DataElement const &de) {
     // This is kind of hackish but since I do not generate other element than the first one: 0x6000 I should be ok:
-    assert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000
+    xassert( GetTag() == de.GetTag() || GetTag().GetGroup() == 0x6000
       || GetTag().GetGroup() == 0x5000 );
-    assert( GetVR().Compatible( de.GetVR() ) ); // In case of VR::INVALID cannot use the & operator
-    assert( !de.IsEmpty() );
+    xassert( GetVR().Compatible( de.GetVR() ) ); // In case of VR::INVALID cannot use the & operator
+    xassert( !de.IsEmpty() );
     const ByteValue *bv = de.GetByteValue();
     SetByteValue(bv);
   }
@@ -689,7 +689,7 @@ public:
   }
 protected:
   void SetByteValue(const ByteValue *bv) {
-    assert( bv ); // FIXME
+    xassert( bv ); // FIXME
     std::stringstream ss;
     std::string s = std::string( bv->GetPointer(), bv->GetLength() );
     Length = bv->GetLength(); // HACK FIXME
@@ -788,7 +788,7 @@ public:
     Internal[i] = sarray.substr(pos1, pos2-pos1);
     // Shouldn't we do the contrary, since we know how many separators
     // (and default behavior is to discard anything after the VM declared
-    assert( GetLength()-1 == i );
+    xassert( GetLength()-1 == i );
     }
 
   unsigned long GetLength() const {
@@ -841,7 +841,7 @@ public:
     if( len ) {
       if( len > Length ) {
         // perform realloc
-        assert( (len / size) * size == len );
+        xassert( (len / size) * size == len );
         ArrayType *internal = new ArrayType[len / size];
         memcpy(internal, Internal, Length * size);
         delete[] Internal;
@@ -863,13 +863,13 @@ public:
       // TODO rewrite this stupid code:
       Length = len;
       //Internal = array;
-      assert(0);
+      throw Exception("Structure error");
       }
   }
   // Implementation of Print is common to all Mode (ASCII/Binary)
   void Print(std::ostream &_os) const {
-    assert( Length );
-    assert( Internal );
+    xassert( Length );
+    xassert( Internal );
     _os << Internal[0]; // VM is at least garantee to be one
     const unsigned long length = GetLength() < 25 ? GetLength() : 25;
     for(unsigned long i=1; i<length; ++i)
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmBasicOffsetTable.h b/Source/DataStructureAndEncodingDefinition/gdcmBasicOffsetTable.h
index 4b22b11..fb40113 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmBasicOffsetTable.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmBasicOffsetTable.h
@@ -33,8 +33,8 @@ public:
 
 /*
   VL GetLength() const {
-    assert( !ValueLengthField.IsUndefined() );
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueLengthField.IsUndefined() );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + ValueLengthField.GetLength()
       + ValueLengthField;
   }
@@ -47,10 +47,9 @@ public:
     const Tag seqDelItem(0xfffe,0xe0dd);
     if( !TagField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
-    //assert( TagField == itemStart );
+    //xassert( TagField == itemStart );
     if( TagField != itemStart )
       {
       // Bug_Siemens_PrivateIconNoItem.dcm
@@ -59,16 +58,14 @@ public:
       }
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     // Self
     SmartPointer<ByteValue> bv = new ByteValue;
     bv->SetLength(ValueLengthField);
     if( !bv->Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     ValueField = bv;
     return is;
@@ -81,25 +78,22 @@ public:
     const Tag seqDelItem(0xfffe,0xe0dd);
     if( !TagField.Write<TSwap>(os) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
-    assert( TagField == itemStart );
+    xassert( TagField == itemStart );
     if( !ValueLengthField.Write<TSwap>(os) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
     if( ValueLengthField )
       {
       // Self
       const ByteValue *bv = GetByteValue();
-      assert( bv );
-      assert( bv->GetLength() == ValueLengthField );
+      xassert( bv );
+      xassert( bv->GetLength() == ValueLengthField );
       if( !bv->Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     return os;
@@ -113,7 +107,7 @@ inline std::ostream &operator<<(std::ostream &os, const BasicOffsetTable &val)
   if( val.ValueField )
     {
     const ByteValue *bv = val.GetByteValue();
-    assert( bv );
+    xassert( bv );
     os << *bv;
     }
 
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmByteBuffer.h b/Source/DataStructureAndEncodingDefinition/gdcmByteBuffer.h
index ce78287..34834fc 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmByteBuffer.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmByteBuffer.h
@@ -82,7 +82,7 @@ public:
         Start = /*buffer =*/ newBuf;
         }
       }
-    assert( (int)Internal.capacity() >= len );
+    xassert( (int)Internal.capacity() >= len );
     return End;
     }
 
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmByteSwapFilter.cxx b/Source/DataStructureAndEncodingDefinition/gdcmByteSwapFilter.cxx
index 4135bcc..2edfa13 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmByteSwapFilter.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmByteSwapFilter.cxx
@@ -39,7 +39,7 @@ bool ByteSwapFilter::ByteSwap()
     {
     const DataElement &de = *it;
     VR const & vr = de.GetVR();
-    //assert( vr & VR::VRASCII || vr & VR::VRBINARY );
+    //xassert( vr & VR::VRASCII || vr & VR::VRBINARY );
     const ByteValue *bv = de.GetByteValue();
     gdcm::SmartPointer<gdcm::SequenceOfItems> si = de.GetValueAsSQ();
     if( de.IsEmpty() )
@@ -47,15 +47,15 @@ bool ByteSwapFilter::ByteSwap()
       }
     else if( bv && !si )
       {
-      assert( !si );
+      xassert( !si );
       // ASCII do not need byte swap
       if( vr & VR::VRBINARY /*&& de.GetTag().IsPrivate()*/ )
         {
-        //assert( de.GetTag().IsPrivate() );
+        //xassert( de.GetTag().IsPrivate() );
         switch(vr)
           {
         case VR::AT:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::FL:
           // FIXME: Technically FL should not be byte-swapped...
@@ -63,22 +63,22 @@ bool ByteSwapFilter::ByteSwap()
           SwapperDoOp::SwapArray((uint32_t*)bv->GetPointer(), bv->GetLength() / sizeof(uint32_t) );
           break;
         case VR::FD:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::OB:
           // I think we are fine, unless this is one of those OB_OW thingy
           break;
         case VR::OF:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::OW:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::SL:
           SwapperDoOp::SwapArray((uint32_t*)bv->GetPointer(), bv->GetLength() / sizeof(uint32_t) );
           break;
         case VR::SQ:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::SS:
           SwapperDoOp::SwapArray((uint16_t*)bv->GetPointer(), bv->GetLength() / sizeof(uint16_t) );
@@ -87,16 +87,16 @@ bool ByteSwapFilter::ByteSwap()
           SwapperDoOp::SwapArray((uint32_t*)bv->GetPointer(), bv->GetLength() / sizeof(uint32_t) );
           break;
         case VR::UN:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         case VR::US:
           SwapperDoOp::SwapArray((uint16_t*)bv->GetPointer(), bv->GetLength() / sizeof(uint16_t) );
           break;
         case VR::UT:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           break;
         default:
-          assert( 0 && "Should not happen" );
+          throw Exception("Structure error");
           }
         }
       }
@@ -119,11 +119,11 @@ bool ByteSwapFilter::ByteSwap()
     else if( const SequenceOfFragments *sf = de.GetSequenceOfFragments() )
       {
       (void)sf;
-      assert( 0 && "Should not happen" );
+      throw Exception("Structure error");
       }
     else
       {
-      assert( 0 && "error" );
+      throw Exception("Structure error");
       }
 
     }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmByteValue.cxx b/Source/DataStructureAndEncodingDefinition/gdcmByteValue.cxx
index 58f6112..46db487 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmByteValue.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmByteValue.cxx
@@ -30,7 +30,7 @@ namespace gdcm_ns
       ++l;
       }
 #else
-    assert( !l.IsUndefined() && !l.IsOdd() );
+    xassert( !l.IsUndefined() && !l.IsOdd() );
 #endif
     // I cannot use reserve for now. I need to implement:
     // STL - vector<> and istream
@@ -64,7 +64,7 @@ namespace gdcm_ns
       }
     // I cannot check IsPrintable some file contains \2 or \0 in a VR::LO element
     // See: acr_image_with_non_printable_in_0051_1010.acr
-    //assert( IsPrintable(length) );
+    //xassert( IsPrintable(length) );
     std::vector<char>::const_iterator it = Internal.begin();
     for(; it != Internal.begin()+length; ++it)
       {
@@ -156,7 +156,7 @@ namespace gdcm_ns
         else
           {
           //in the rare case there are more ^ characters
-          assert("Name components exceeded");
+          xassert("Name components exceeded");
           }
         }
       else if ( c == '=' )
@@ -201,7 +201,7 @@ namespace gdcm_ns
           }
         else
           {
-          assert("Impossible - only 3 names allowed");
+          xassert("Impossible - only 3 names allowed");
           }
         count2=1;
         }
@@ -325,7 +325,7 @@ namespace gdcm_ns
     Internal.insert( Internal.end(), bv.Internal.begin(), bv.Internal.end());
     Length += bv.Length;
     // post condition
-    assert( Internal.size() % 2 == 0 && Internal.size() == Length );
+    xassert( Internal.size() % 2 == 0 && Internal.size() == Length );
     }
    
 } // end namespace gdcm_ns
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmByteValue.h b/Source/DataStructureAndEncodingDefinition/gdcmByteValue.h
index 3ef0dd9..76f7ae5 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmByteValue.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmByteValue.h
@@ -49,7 +49,7 @@ public:
   ByteValue(std::vector<char> &v):Internal(v),Length((uint32_t)v.size()) {}
   //ByteValue(std::ostringstream const &os) {
   //  (void)os;
-  //   assert(0); // TODO
+  //   throw Exception("Unimplemented"); // TODO
   //}
   ~ByteValue() {
     Internal.clear();
@@ -63,13 +63,13 @@ public:
 
   // Either from Element Number (== 0x0000)
   void PrintGroupLength(std::ostream &os) {
-    assert( Length == 2 );
+    xassert( Length == 2 );
     (void)os;
   }
 
   bool IsEmpty() const {
 #if 0
-    if( Internal.empty() ) assert( Length == 0 );
+    if( Internal.empty() ) xassert( Length == 0 );
     return Internal.empty();
 #else
   return Length == 0;
@@ -120,8 +120,8 @@ public:
   bool GetBuffer(char *buffer, unsigned long length) const;
   bool WriteBuffer(std::ostream &os) const {
     if( Length ) {
-      //assert( Internal.size() <= Length );
-      assert( !(Internal.size() % 2) );
+      //xassert( Internal.size() <= Length );
+      xassert( !(Internal.size() % 2) );
       os.write(&Internal[0], Internal.size() );
       }
     return true;
@@ -138,7 +138,7 @@ public:
       if( readvalues )
         {
         is.read(&Internal[0], Length);
-        assert( Internal.size() == Length || Internal.size() == Length + 1 );
+        xassert( Internal.size() == Length || Internal.size() == Length + 1 );
         TSwap::SwapArray((TType*)&Internal[0], Internal.size() / sizeof(TType) );
         }
       else
@@ -157,7 +157,7 @@ public:
 
   template <typename TSwap, typename TType>
   std::ostream const &Write(std::ostream &os) const {
-    assert( !(Internal.size() % 2) );
+    xassert( !(Internal.size() % 2) );
     if( !Internal.empty() ) {
       //os.write(&Internal[0], Internal.size());
       std::vector<char> copy = Internal;
@@ -179,7 +179,7 @@ public:
    *         UNICODE or character set...
    */
   bool IsPrintable(VL length) const {
-    assert( length <= Length );
+    xassert( length <= Length );
     for(unsigned int i=0; i<length; i++)
       {
       if ( i == (length-1) && Internal[i] == '\0') continue;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.cxx
index c4d8be6..45fe1d3 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL CP246ExplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -37,18 +37,17 @@ VL CP246ExplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & VR::OB_OW );
+      xassert( VRField & VR::OB_OW );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
-    assert(0);
-  return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + 2*VRField.GetLength() + ValueLengthField;
     }
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.txx
index 355081c..016539a 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmCP246ExplicitDataElement.txx
@@ -44,18 +44,17 @@ std::istream &CP246ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !is.eof() ) // FIXME This should not be needed
       {
-      assert(0 && "Should not happen" );
+      throw Exception("Truncated file");
       }
     return is;
     }
-  assert( TagField != Tag(0xfffe,0xe0dd) );
+  xassert( TagField != Tag(0xfffe,0xe0dd) );
   const Tag itemDelItem(0xfffe,0xe00d);
   if( TagField == itemDelItem )
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( ValueLengthField != 0 )
       {
@@ -72,20 +71,19 @@ std::istream &CP246ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !VRField.Read(is) )
       {
-      assert(0 && "Should not happen" );
-      return is;
+      throw Exception("Truncated file");
       }
     }
   catch( std::exception & )
     {
     // gdcm-MR-PHILIPS-16-Multi-Seq.dcm
-    // assert( TagField == Tag(0xfffe, 0xe000) );
+    // xassert( TagField == Tag(0xfffe, 0xe000) );
     // -> For some reason VR is written as {44,0} well I guess this is a VR...
     // Technically there is a second bug, dcmtk assume other things when reading this tag,
     // so I need to change this tag too, if I ever want dcmtk to read this file. oh well
     // 0019004_Baseline_IMG1.dcm
     // -> VR is garbage also...
-    // assert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
+    // xassert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
     gdcmWarningMacro( "Assuming 16 bits VR for Tag=" <<
       TagField << " in order to read a buggy DICOM file." );
     VRField = VR::INVALID;
@@ -95,8 +93,7 @@ std::istream &CP246ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     }
   else
@@ -128,11 +125,11 @@ std::istream &CP246ExplicitDataElement::ReadValue(std::istream &is, bool readval
 
   //std::cerr << "exp cur tag=" << TagField << " VR=" << VRField << " VL=" << ValueLengthField << std::endl;
   // Read the Value
-  //assert( ValueField == 0 );
+  //xassert( ValueField == 0 );
   if( VRField == VR::SQ )
     {
     // Check whether or not this is an undefined length sequence
-    assert( TagField != Tag(0x7fe0,0x0010) );
+    xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new SequenceOfItems;
     }
   else if( ValueLengthField.IsUndefined() )
@@ -143,14 +140,14 @@ std::istream &CP246ExplicitDataElement::ReadValue(std::istream &is, bool readval
       // Enhanced_MR_Image_Storage_PixelSpacingNotIn_0028_0030.dcm (illegal)
       // vs
       // undefined_length_un_vr.dcm
-      assert( TagField != Tag(0x7fe0,0x0010) );
+      xassert( TagField != Tag(0x7fe0,0x0010) );
       ValueField = new SequenceOfItems;
       ValueField->SetLength(ValueLengthField); // perform realloc
       try
         {
         if( !ValueIO<CP246ExplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) ) // non cp246
           {
-          assert(0);
+          throw Exception("Truncated file");
           }
         }
       catch( std::exception &)
@@ -167,14 +164,14 @@ std::istream &CP246ExplicitDataElement::ReadValue(std::istream &is, bool readval
     else
       {
       // Ok this is Pixel Data fragmented...
-      assert( TagField == Tag(0x7fe0,0x0010) );
-      assert( VRField & VR::OB_OW );
+      xassert( TagField == Tag(0x7fe0,0x0010) );
+      xassert( VRField & VR::OB_OW );
       ValueField = new SequenceOfFragments;
       }
     }
   else
     {
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new ByteValue;
     }
   // We have the length we should be able to read the value
@@ -191,12 +188,12 @@ std::istream &CP246ExplicitDataElement::ReadValue(std::istream &is, bool readval
   )
     {
     gdcmWarningMacro( "ByteSwaping Private SQ: " << TagField );
-    assert( VRField == VR::SQ );
+    xassert( VRField == VR::SQ );
     try
       {
       if( !ValueIO<CP246ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
         {
-        assert(0 && "Should not happen");
+        throw Exception("Truncated file");
         }
       }
     catch( std::exception & )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmCSAElement.h b/Source/DataStructureAndEncodingDefinition/gdcmCSAElement.h
index 6885e2d..ea7b2f3 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmCSAElement.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmCSAElement.h
@@ -61,7 +61,7 @@ public:
   Value const &GetValue() const { return *DataField; }
   Value &GetValue() { return *DataField; }
   void SetValue(Value const & vl) {
-    //assert( DataField == 0 );
+    //xassert( DataField == 0 );
     DataField = vl;
   }
   /// Check if CSA Element is empty
@@ -140,7 +140,7 @@ inline std::ostream& operator<<(std::ostream &os, const CSAElement &val)
     {
     //val.DataField->Print( os << "'" );
     const ByteValue * bv = dynamic_cast<ByteValue*>(&*val.DataField);
-    assert( bv );
+    xassert( bv );
     const char * p = bv->GetPointer();
     std::string str(p, p + bv->GetLength() );
     if( val.ValueMultiplicityField == VM::VM1 )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmCSAHeader.cxx b/Source/DataStructureAndEncodingDefinition/gdcmCSAHeader.cxx
index fc3c0b2..55468e4 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmCSAHeader.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmCSAHeader.cxx
@@ -910,16 +910,16 @@ bool check_mapping(uint32_t syngodt, const char *vr)
 {
   static const unsigned int max = sizeof(mapping) / sizeof(equ);
   const equ *p = mapping;
-  assert( syngodt <= mapping[max-1].syngodt ); (void)max;
+  xassert( syngodt <= mapping[max-1].syngodt ); (void)max;
   while(p->syngodt < syngodt )
     {
     //std::cout << "mapping:" << p->vr << std::endl;
     ++p;
     }
-  assert( p->syngodt == syngodt ); // or else need to update mapping
+  xassert( p->syngodt == syngodt ); // or else need to update mapping
   const char* lvr = p->vr;
   int check = strcmp(vr, lvr) == 0;
-  assert( check ); (void)check;
+  xassert( check ); (void)check;
   return true;
 }
 
@@ -977,9 +977,9 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
   gdcmDebugMacro( "found type" );
 
   const ByteValue *bv = de.GetByteValue();
-  assert( bv );
+  xassert( bv );
   const char *p = bv->GetPointer();
-  assert( p );
+  xassert( p );
   std::string s( bv->GetPointer(), bv->GetLength() );
   std::stringstream ss;
   ss.str( s );
@@ -1034,10 +1034,10 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
           {
           ds.InsertDataElement( xde ); // Cannot use Insert since Group = 0x0 (< 0x8)
           //VR refvr = GetVRFromDataSetFormatDict( xde.GetTag() );
-          //assert( xde.GetVR() == refvr );
+          //xassert( xde.GetVR() == refvr );
           }
         //std::cout << ds << std::endl;
-        assert( ss.eof() );
+        xassert( ss.eof() );
         }
       catch(std::exception &)
         {
@@ -1048,7 +1048,7 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
       }
     else
       {
-      //assert(0);
+      //throw Exception("Structure error");
       ss.seekg( 0, std::ios::beg );
       // No magic number for this one:
       // SIEMENS_Sonata-16-MONO2-Value_Multiplicity.dcm
@@ -1059,10 +1059,10 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
     {
     // NEW FORMAT !
     ss.read(signature, 4);
-    assert( strcmp( signature, "\4\3\2\1" ) == 0 );
+    xassert( strcmp( signature, "\4\3\2\1" ) == 0 );
     InternalType = SV10;
     }
-  assert( InternalType != UNKNOWN );
+  xassert( InternalType != UNKNOWN );
   gdcmDebugMacro( "Found Type: " << (int)InternalType );
 
   uint32_t n;
@@ -1076,7 +1076,7 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
     gdcmErrorMacro( "Must be a new format. Giving up" );
     return false;
     }
-  assert( unused == 77 ); // 'M' character...
+  xassert( unused == 77 ); // 'M' character...
 
   for(uint32_t i = 0; i < n; ++i)
     {
@@ -1093,12 +1093,12 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
     ss.read((char*)&vm, sizeof(vm));
     SwapperNoOp::SwapArray(&vm,1);
     csael.SetVM( VM::GetVMTypeFromLength(vm,1) );
-    //assert( csael.GetVM() != VM::VM0 );
+    //xassert( csael.GetVM() != VM::VM0 );
     //std::cout << "VM " << vm <<  ", ";
     char vr[4];
     ss.read(vr, 4);
     // In dataset without magic signature (OLD FORMAT) vr[3] is garbage...
-    assert( /*vr[3] == 0 &&*/ vr[2] == 0 );
+    xassert( /*vr[3] == 0 &&*/ vr[2] == 0 );
     csael.SetVR( VR::GetVRTypeFromFile(vr) );
     //std::cout << "VR " << vr << ", ";
     uint32_t syngodt;
@@ -1121,7 +1121,7 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
     ss.read((char*)&xx, sizeof(xx));
     SwapperNoOp::SwapArray(&xx,1);
     //std::cout << "xx=" << xx<< std::endl;
-    assert( xx == 77 || xx == 205 );
+    xassert( xx == 77 || xx == 205 );
 
     //std::cout << "Data ";
     std::ostringstream os;
@@ -1130,9 +1130,9 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
       uint32_t item_xx[4];
       ss.read((char*)&item_xx, 4*sizeof(uint32_t));
       SwapperNoOp::SwapArray(item_xx,4);
-      assert( item_xx[2] == 77 || item_xx[2] == 205 );
+      xassert( item_xx[2] == 77 || item_xx[2] == 205 );
       uint32_t len = item_xx[1]; // 2nd element
-      assert( item_xx[0] == item_xx[1] && item_xx[1] == item_xx[3] );
+      xassert( item_xx[0] == item_xx[1] && item_xx[1] == item_xx[3] );
       if( len )
         {
         char *val = new char[len+1];
@@ -1155,7 +1155,7 @@ bool CSAHeader::LoadFromDataElement(DataElement const &de)
         for(uint32_t d= 0; d < dummy_len; ++d)
           {
           // dummy[d]  is zero in the NEW format
-          //assert( dummy[d] == 0 );
+          //xassert( dummy[d] == 0 );
           //for the old format there appears to be some garbage:
           if( dummy[d] )
             {
@@ -1207,7 +1207,7 @@ const CSAElement &CSAHeader::GetCSAElementByName(const char *name)
     for(; it != InternalCSADataSet.end(); ++it)
       {
       const char *itname = it->GetName();
-      assert( itname );
+      xassert( itname );
       if( strcmp(name, itname) == 0 )
         {
         return *it;
@@ -1225,7 +1225,7 @@ bool CSAHeader::FindCSAElementByName(const char *name)
     for(; it != InternalCSADataSet.end(); ++it)
       {
       const char *itname = it->GetName();
-      assert( itname );
+      xassert( itname );
       if( strcmp(name, itname) == 0 )
         {
         return true;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmDataElement.cxx
index ad63cf3..9c4379d 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmDataElement.cxx
@@ -23,13 +23,13 @@
 namespace gdcm_ns
 {
   void DataElement::SetVLToUndefined() {
-    assert( VRField == VR::SQ || VRField == VR::INVALID
+    xassert( VRField == VR::SQ || VRField == VR::INVALID
       || (VRField == VR::UN /*&& IsUndefinedLength()*/ ) );
     SequenceOfItems *sqi = dynamic_cast<SequenceOfItems*>(ValueField.GetPointer());
     if( sqi )
       {
       sqi->SetLengthToUndefined();
-      assert( GetValueAsSQ()->IsUndefinedLength() );
+      xassert( GetValueAsSQ()->IsUndefinedLength() );
       }
     ValueLengthField.SetToUndefined();
   }
@@ -61,7 +61,7 @@ namespace gdcm_ns
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(ValueField.GetPointer());
     if( sq ) // all set !
       {
-      //assert( GetVR() == VR::SQ );
+      //xassert( GetVR() == VR::SQ );
       SmartPointer<SequenceOfItems> sqi = sq;
       return sqi;
       }
@@ -72,7 +72,7 @@ namespace gdcm_ns
         if( GetVR() == VR::INVALID )
           {
           const ByteValue *bv = GetByteValue();
-          assert( bv );
+          xassert( bv );
           SequenceOfItems *sqi = new SequenceOfItems;
           sqi->SetLength( bv->GetLength() );
           std::string s( bv->GetPointer(), bv->GetLength() );
@@ -111,9 +111,9 @@ namespace gdcm_ns
           }
         else if  ( GetVR() == VR::UN ) // cp 246, IVRLE SQ
           {
-          assert( GetVR() == VR::UN ); // cp 246, IVRLE SQ
+          xassert( GetVR() == VR::UN ); // cp 246, IVRLE SQ
           const ByteValue *bv = GetByteValue();
-          assert( bv );
+          xassert( bv );
           SequenceOfItems *sqi = new SequenceOfItems;
           sqi->SetLength( bv->GetLength() );
           std::string s( bv->GetPointer(), bv->GetLength() );
@@ -161,8 +161,8 @@ namespace gdcm_ns
           }
         else
           {
-          assert( GetVR().IsVRFile() );
-          assert( GetByteValue() );
+          xassert( GetVR().IsVRFile() );
+          xassert( GetByteValue() );
           return 0;
           }
         }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmDataElement.h b/Source/DataStructureAndEncodingDefinition/gdcmDataElement.h
index ceedc25..87c0269 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmDataElement.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmDataElement.h
@@ -95,7 +95,7 @@ public:
   Value &GetValue() { return *ValueField; }
   /// \warning you need to set the ValueLengthField explicitly
   void SetValue(Value const & vl) {
-    //assert( ValueField == 0 );
+    //xassert( ValueField == 0 );
     ValueField = vl;
     ValueLengthField = vl.GetLength();
   }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.cxx b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.cxx
index 1d6cc3d..1ecb3fd 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.cxx
@@ -40,7 +40,7 @@ std::string DataSet::GetPrivateCreator(const Tag &t) const
       const DataElement &de = *it;
       if( de.IsEmpty() ) return "";
       const ByteValue *bv = de.GetByteValue();
-      assert( bv );
+      xassert( bv );
       std::string owner = std::string(bv->GetPointer(),bv->GetLength());
       // There should not be any trailing space character...
       // TODO: tmp.erase(tmp.find_last_not_of(' ') + 1);
@@ -49,7 +49,7 @@ std::string DataSet::GetPrivateCreator(const Tag &t) const
         // osirix/AbdominalCT/36382443
         owner.erase(owner.size()-1,1);
         }
-      assert( owner.size() == 0 || owner[owner.size()-1] != ' ' );
+      xassert( owner.size() == 0 || owner[owner.size()-1] != ' ' );
       return owner;
       }
     }
@@ -59,17 +59,17 @@ std::string DataSet::GetPrivateCreator(const Tag &t) const
 Tag DataSet::ComputeDataElement(const PrivateTag & t) const
 {
   gdcmDebugMacro( "Entering ComputeDataElement" );
-  //assert( t.IsPrivateCreator() ); // No this is wrong to do the assert: eg. (0x07a1,0x000a,"ELSCINT1")
+  //xassert( t.IsPrivateCreator() ); // No this is wrong to do the assert: eg. (0x07a1,0x000a,"ELSCINT1")
   // is valid because we have not yet done the mapping, so 0xa < 0x10 fails but might not later on
   const Tag start(t.GetGroup(), 0x0010 ); // First possible private creator (0x0 -> 0x9 are reserved...)
   const DataElement r(start);
   ConstIterator it = DES.lower_bound(r);
   const char *refowner = t.GetOwner();
-  assert( refowner );
+  xassert( refowner );
   bool found = false;
   while( it != DES.end() && it->GetTag().GetGroup() == t.GetGroup() && it->GetTag().GetElement() < 0x100 )
     {
-    //assert( it->GetTag().GetOwner() );
+    //xassert( it->GetTag().GetOwner() );
     const ByteValue * bv = it->GetByteValue();
     if( bv )
       {
@@ -77,7 +77,7 @@ Tag DataSet::ComputeDataElement(const PrivateTag & t) const
       std::string tmp(bv->GetPointer(),bv->GetLength());
       // trim trailing whitespaces:
       tmp.erase(tmp.find_last_not_of(' ') + 1);
-      assert( tmp.size() == 0 || tmp[ tmp.size() - 1 ] != ' ' ); // FIXME
+      xassert( tmp.size() == 0 || tmp[ tmp.size() - 1 ] != ' ' ); // FIXME
       if( System::StrCaseCmp( tmp.c_str(), refowner ) == 0 )
         {
         // found !
@@ -127,7 +127,7 @@ MediaStorage DataSet::GetMediaStorage() const
   std::string ts;
     {
     const ByteValue *bv = de.GetByteValue();
-    assert( bv );
+    xassert( bv );
     if( bv->GetPointer() && bv->GetLength() )
       {
       // Pad string with a \0
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.h b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.h
index 198ef58..bc934bf 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.h
@@ -69,7 +69,7 @@ public:
   DataElementSet &GetDES() { return DES; }
   void Clear() {
     DES.clear();
-    assert( DES.empty() );
+    xassert( DES.empty() );
   }
 
   SizeType Size() const {
@@ -79,7 +79,7 @@ public:
   void Print(std::ostream &os, std::string const &indent = "") const {
     // CT_Phillips_JPEG2K_Decompr_Problem.dcm has a SQ of length == 0
     //int s = DES.size();
-    //assert( s );
+    //xassert( s );
     //std::copy(DES.begin(), DES.end(),
     //  std::ostream_iterator<DataElement>(os, "\n"));
     ConstIterator it = DES.begin();
@@ -92,15 +92,15 @@ public:
   template <typename TDE>
   unsigned int ComputeGroupLength(Tag const &tag) const
     {
-    assert( tag.GetElement() == 0x0 );
+    xassert( tag.GetElement() == 0x0 );
     const DataElement r(tag);
     ConstIterator it = DES.find(r);
     unsigned int res = 0;
     for( ++it; it != DES.end()
       && it->GetTag().GetGroup() == tag.GetGroup(); ++it)
       {
-      assert( it->GetTag().GetElement() != 0x0 );
-      assert( it->GetTag().GetGroup() == tag.GetGroup() );
+      xassert( it->GetTag().GetElement() != 0x0 );
+      xassert( it->GetTag().GetGroup() == tag.GetGroup() );
       res += it->GetLength<TDE>();
       }
     return res;
@@ -109,13 +109,13 @@ public:
   template <typename TDE>
   VL GetLength() const {
     if( DES.empty() ) return 0;
-    assert( !DES.empty() );
+    xassert( !DES.empty() );
     VL ll = 0;
-    assert( ll == 0 );
+    xassert( ll == 0 );
     ConstIterator it = DES.begin();
     for( ; it != DES.end(); ++it)
       {
-      assert( !(it->GetLength<TDE>().IsUndefined()) );
+      xassert( !(it->GetLength<TDE>().IsUndefined()) );
       if ( it->GetTag() != Tag(0xfffe,0xe00d) )
         {
         ll += it->GetLength<TDE>();
@@ -171,7 +171,7 @@ public:
   /// Completely remove a dataelement from the dataset
   SizeType Remove(const Tag& tag) {
     DataElementSet::size_type count = DES.erase(tag);
-    assert( count == 0 || count == 1 );
+    xassert( count == 0 || count == 1 );
     return count;
   }
 
@@ -236,7 +236,7 @@ public:
 /*
   template <typename TOperation>
   void ExecuteOperation(TOperation & operation) {
-    assert( !DES.empty() );
+    xassert( !DES.empty() );
     DataElementSet::iterator it = Begin();
     for( ; it != End(); ++it)
       {
@@ -299,7 +299,7 @@ protected:
 #else
     DES.insert(de);
 #endif
-    assert( de.IsEmpty() || de.GetVL() == de.GetValue().GetLength() );
+    xassert( de.IsEmpty() || de.GetVL() == de.GetValue().GetLength() );
     }
 
 protected:
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.txx b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.txx
index 0affabe..071e1a3 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmDataSet.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmDataSet.txx
@@ -26,7 +26,7 @@ namespace gdcm_ns
   std::istream &DataSet::ReadNested(std::istream &is) {
     DataElement de;
     const Tag itemDelItem(0xfffe,0xe00d);
-    assert( de.GetTag() != itemDelItem ); // precondition before while loop
+    xassert( de.GetTag() != itemDelItem ); // precondition before while loop
     try
       {
       while( de.Read<TDE,TSwap>(is) && de.GetTag() != itemDelItem  ) // Keep that order please !
@@ -51,7 +51,7 @@ namespace gdcm_ns
         throw pe;
         }
       }
-    assert( de.GetTag() == itemDelItem );
+    xassert( de.GetTag() == itemDelItem );
     return is;
   }
 
@@ -79,14 +79,14 @@ namespace gdcm_ns
         }
       else
         {
-        assert( is.good() );
+        xassert( is.good() );
         if( de.GetTag() != t )
           is.seekg( de.GetVL(), std::ios::cur );
         }
       // tag was found, we can exit the loop:
       if ( t <= de.GetTag() )
         {
-        assert( is.good() );
+        xassert( is.good() );
         break;
         }
       }
@@ -106,14 +106,14 @@ namespace gdcm_ns
         }
       else
         {
-        assert( is.good() );
+        xassert( is.good() );
         if( de.GetTag() != t )
           is.seekg( de.GetVL(), std::ios::cur );
         }
       // tag was found, we can exit the loop:
       if ( t <= de.GetTag() )
         {
-        assert( is.good() );
+        xassert( is.good() );
         break;
         }
       }
@@ -171,7 +171,7 @@ namespace gdcm_ns
           }
         }
       }
-    assert( inputStream.good() );
+    xassert( inputStream.good() );
     return inputStream;
     }
 
@@ -179,11 +179,11 @@ namespace gdcm_ns
   std::istream &DataSet::ReadSelectedPrivateTags(std::istream &inputStream, const std::set<PrivateTag> & selectedPTags, bool readvalues) {
     if ( ! (selectedPTags.empty() || inputStream.fail()) )
       {
-      assert( selectedPTags.size() == 1 );
+      xassert( selectedPTags.size() == 1 );
       const PrivateTag refPTag = *(selectedPTags.rbegin());
       PrivateTag nextPTag = refPTag;
       nextPTag.SetElement( (uint16_t)(nextPTag.GetElement() + 0x1) );
-      assert( nextPTag.GetElement() & 0x00ff ); // no wrap please
+      xassert( nextPTag.GetElement() & 0x00ff ); // no wrap please
       Tag maxTag;
       maxTag.SetPrivateCreator( nextPTag );
       DataElement dataElem;
@@ -299,11 +299,11 @@ namespace gdcm_ns
     (void)length;
     if ( ! (selectedPTags.empty() || inputStream.fail()) )
       {
-      assert( selectedPTags.size() == 1 );
+      xassert( selectedPTags.size() == 1 );
       const PrivateTag refPTag = *(selectedPTags.rbegin());
       PrivateTag nextPTag = refPTag;
       nextPTag.SetElement( (uint16_t)(nextPTag.GetElement() + 0x1) );
-      assert( nextPTag.GetElement() ); // no wrap please
+      xassert( nextPTag.GetElement() ); // no wrap please
       Tag maxTag;
       maxTag.SetPrivateCreator( nextPTag );
       DataElement dataElem;
@@ -367,16 +367,16 @@ namespace gdcm_ns
         {
         //std::cout << "Nested: " << de << std::endl;
 #ifndef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
-        assert( de.GetTag() != Tag(0xfffe,0xe000) ); // We should not be reading the next item...
+        xassert( de.GetTag() != Tag(0xfffe,0xe000) ); // We should not be reading the next item...
 #endif
         InsertDataElement( de );
         const VL oflen = de.GetLength<TDE>();
         l += oflen;
         const std::streampos curpos = is.tellg();
-        //assert( (curpos - startpos) == l || (curpos - startpos) + 1 == l );
+        //xassert( (curpos - startpos) == l || (curpos - startpos) + 1 == l );
 
         //std::cout << "l:" << l << std::endl;
-        //assert( !de.GetVL().IsUndefined() );
+        //xassert( !de.GetVL().IsUndefined() );
         //std::cerr << "DEBUG: " << de.GetTag() << " "<< de.GetLength() <<
         //  "," << de.GetVL() << "," << l << std::endl;
         // Bug_Philips_ItemTag_3F3F
@@ -415,7 +415,7 @@ namespace gdcm_ns
         {
         // gdcm-MR-PHILIPS-16-Multi-Seq.dcm
         // Long story short, I think Philips engineer inserted 0xfffe,0x0000 instead of an item start element
-        // assert( FindDataElement( Tag(0xfffe,0x0000) ) == false );
+        // xassert( FindDataElement( Tag(0xfffe,0x0000) ) == false );
         is.seekg(-6, std::ios::cur );
         length = locallength = l;
         }
@@ -445,15 +445,15 @@ namespace gdcm_ns
           }
         // seek back since we read the next item starter:
         int iteml = de.GetLength<TDE>();
-        //assert( de.GetTag().GetElement() );
+        //xassert( de.GetTag().GetElement() );
         if( !de.GetTag().GetElement() )
           {
-          assert( iteml == 12 ); (void)iteml;
+          xassert( iteml == 12 ); (void)iteml;
           is.seekg( -12, std::ios::cur );
           }
         else
           {
-          //assert( de.GetTag() == Tag(0xfffe,0xe000) );
+          //xassert( de.GetTag() == Tag(0xfffe,0xe000) );
           is.seekg( -4, std::ios::cur );
           }
         // let's fix the length now:
@@ -475,8 +475,8 @@ namespace gdcm_ns
 
     // technically we could only do this assert if the dataset did not contains
     // duplicate data elements so only do a <= instead:
-    //assert( l == locallength );
-    assert( l <= locallength );
+    //xassert( l == locallength );
+    xassert( l <= locallength );
     return is;
   }
 
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmElement.h b/Source/DataStructureAndEncodingDefinition/gdcmElement.h
index d4ace85..11eb0a9 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmElement.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmElement.h
@@ -92,18 +92,18 @@ public:
     return Internal;
   }
   const typename VRToType<TVR>::Type &GetValue(unsigned int idx = 0) const {
-    assert( idx < VMToLength<TVM>::Length );
+    xassert( idx < VMToLength<TVM>::Length );
     return Internal[idx];
   }
   typename VRToType<TVR>::Type &GetValue(unsigned int idx = 0) {
-    assert( idx < VMToLength<TVM>::Length );
+    xassert( idx < VMToLength<TVM>::Length );
     return Internal[idx];
   }
   typename VRToType<TVR>::Type operator[] (unsigned int idx) const {
     return GetValue(idx);
   }
   void SetValue(typename VRToType<TVR>::Type v, unsigned int idx = 0) {
-    assert( idx < VMToLength<TVM>::Length );
+    xassert( idx < VMToLength<TVM>::Length );
     Internal[idx] = v;
   }
 
@@ -130,7 +130,7 @@ public:
     EncodingImplementation<VRToEncoding<TVR>::Mode>::Write(Internal,
       GetLength(),os);
     ret.SetVR( (VR::VRType)TVR );
-    assert( ret.GetVR() != VR::SQ );
+    xassert( ret.GetVR() != VR::SQ );
     if( (VR::VRType)VRToEncoding<TVR>::Mode == VR::VRASCII )
       {
       if( GetVR() != VR::UI )
@@ -172,7 +172,7 @@ public:
 protected:
   void SetNoSwap(Value const &v) {
     const ByteValue *bv = dynamic_cast<const ByteValue*>(&v);
-    assert( bv ); // That would be bad...
+    xassert( bv ); // That would be bad...
     //memcpy(Internal, bv->GetPointer(), bv->GetLength());
     std::stringstream ss;
     std::string s = std::string( bv->GetPointer(), bv->GetLength() );
@@ -203,18 +203,18 @@ public:
   template<typename T> // FIXME this should be VRToType<TVR>::Type
   static inline void ReadComputeLength(T* data, unsigned int &length,
                           std::istream &_is) {
-    assert( data );
-    //assert( length ); // != 0
+    xassert( data );
+    //xassert( length ); // != 0
     length = 0;
-    assert( _is );
+    xassert( _is );
 #if 0
     char sep;
     while( _is >> data[length++] )
       {
       // Get the separator in between the values
-      assert( _is );
+      xassert( _is );
       _is.get(sep);
-      assert( sep == '\\' || sep == ' ' ); // FIXME: Bad use of assert
+      xassert( sep == '\\' || sep == ' ' ); // FIXME: Bad use of assert
       if( sep == ' ' ) length--; // FIXME
       }
 #else
@@ -227,19 +227,19 @@ public:
   template<typename T> // FIXME this should be VRToType<TVR>::Type
   static inline void Read(T* data, unsigned long length,
                           std::istream &_is) {
-    assert( data );
-    assert( length ); // != 0
-    assert( _is );
+    xassert( data );
+    xassert( length ); // != 0
+    xassert( _is );
     // FIXME BUG: what if >> operation fails ?
     // gdcmData/MR00010001.dcm / SpacingBetweenSlices
     _is >> std::ws >> data[0];
     char sep;
     //std::cout << "GetLength: " << af->GetLength() << std::endl;
     for(unsigned long i=1; i<length;++i) {
-      assert( _is );
+      xassert( _is );
       // Get the separator in between the values
       _is >> std::ws >> sep; //_is.get(sep);
-      assert( sep == '\\' ); // FIXME: Bad use of assert
+      xassert( sep == '\\' ); // FIXME: Bad use of assert
       _is >> std::ws >> data[i];
       }
     }
@@ -252,12 +252,12 @@ public:
   template<typename T>
   static inline void Write(const T* data, unsigned long length,
                            std::ostream &_os)  {
-    assert( data );
-    assert( length );
-    assert( _os );
+    xassert( data );
+    xassert( length );
+    xassert( _os );
     _os << data[0];
     for(unsigned long i=1; i<length; ++i) {
-      assert( _os );
+      xassert( _os );
       _os << "\\" << data[i];
       }
     }
@@ -287,7 +287,7 @@ static size_t shrink(char *fp_buffer) {
   long long mant;
   int n0, n1;
   int n = sscanf(fp_buffer, "%d.%n%lld%ne%d", &lead, &n0, &mant, &n1, &expo);
-  assert(n == 3);
+  xassert(n == 3);
   return sprintf(fp_buffer, "%d%0*llde%d", lead, n1 - n0, mant,
           expo - (n1 - n0));
 }
@@ -322,9 +322,9 @@ static int x16printf(char *dest, size_t width, Float value) {
 /* Writing VR::DS is not that easy after all */
 // http://groups.google.com/group/comp.lang.c++/browse_thread/thread/69ccd26f000a0802
 template<> inline void EncodingImplementation<VR::VRASCII>::Write(const float * data, unsigned long length, std::ostream &_os)  {
-    assert( data );
-    assert( length );
-    assert( _os );
+    xassert( data );
+    xassert( length );
+    xassert( _os );
 #ifdef VRDS16ILLEGAL
     _os << to_string(data[0]);
 #else
@@ -333,7 +333,7 @@ template<> inline void EncodingImplementation<VR::VRASCII>::Write(const float *
     _os << buf;
 #endif
     for(unsigned long i=1; i<length; ++i) {
-      assert( _os );
+      xassert( _os );
 #ifdef VRDS16ILLEGAL
       _os << "\\" << to_string(data[i]);
 #else
@@ -344,9 +344,9 @@ template<> inline void EncodingImplementation<VR::VRASCII>::Write(const float *
     }
 
 template<> inline void EncodingImplementation<VR::VRASCII>::Write(const double* data, unsigned long length, std::ostream &_os)  {
-    assert( data );
-    assert( length );
-    assert( _os );
+    xassert( data );
+    xassert( length );
+    xassert( _os );
 #ifdef VRDS16ILLEGAL
     _os << to_string(data[0]);
 #else
@@ -355,7 +355,7 @@ template<> inline void EncodingImplementation<VR::VRASCII>::Write(const double*
     _os << buf;
 #endif
     for(unsigned long i=1; i<length; ++i) {
-      assert( _os );
+      xassert( _os );
 #ifdef VRDS16ILLEGAL
       _os << "\\" << to_string(data[i]);
 #else
@@ -377,13 +377,13 @@ public:
     static inline void ReadComputeLength(T* data, unsigned int &length,
       std::istream &_is) {
     const unsigned int type_size = sizeof(T);
-    assert( data ); // Can we read from pointer ?
-    //assert( length );
+    xassert( data ); // Can we read from pointer ?
+    //xassert( length );
     length /= type_size;
-    assert( _is ); // Is stream valid ?
+    xassert( _is ); // Is stream valid ?
     _is.read( reinterpret_cast<char*>(data+0), type_size);
     for(unsigned long i=1; i<length; ++i) {
-      assert( _is );
+      xassert( _is );
       _is.read( reinterpret_cast<char*>(data+i), type_size );
     }
     }
@@ -391,12 +391,12 @@ public:
   static inline void ReadNoSwap(T* data, unsigned long length,
     std::istream &_is) {
     const unsigned int type_size = sizeof(T);
-    assert( data ); // Can we read from pointer ?
-    assert( length );
-    assert( _is ); // Is stream valid ?
+    xassert( data ); // Can we read from pointer ?
+    xassert( length );
+    xassert( _is ); // Is stream valid ?
     _is.read( reinterpret_cast<char*>(data+0), type_size);
     for(unsigned long i=1; i<length; ++i) {
-      assert( _is );
+      xassert( _is );
       _is.read( reinterpret_cast<char*>(data+i), type_size );
     }
     //ByteSwap<T>::SwapRangeFromSwapCodeIntoSystem(data,
@@ -407,12 +407,12 @@ public:
   static inline void Read(T* data, unsigned long length,
     std::istream &_is) {
     const unsigned int type_size = sizeof(T);
-    assert( data ); // Can we read from pointer ?
-    assert( length );
-    assert( _is ); // Is stream valid ?
+    xassert( data ); // Can we read from pointer ?
+    xassert( length );
+    xassert( _is ); // Is stream valid ?
     _is.read( reinterpret_cast<char*>(data+0), type_size);
     for(unsigned long i=1; i<length; ++i) {
-      assert( _is );
+      xassert( _is );
       _is.read( reinterpret_cast<char*>(data+i), type_size );
     }
     //ByteSwap<T>::SwapRangeFromSwapCodeIntoSystem(data,
@@ -423,15 +423,15 @@ public:
   static inline void Write(const T* data, unsigned long length,
     std::ostream &_os) {
     const unsigned int type_size = sizeof(T);
-    assert( data ); // Can we write into pointer ?
-    assert( length );
-    assert( _os ); // Is stream valid ?
+    xassert( data ); // Can we write into pointer ?
+    xassert( length );
+    xassert( _os ); // Is stream valid ?
     //ByteSwap<T>::SwapRangeFromSwapCodeIntoSystem((T*)data,
     //  _os.GetSwapCode(), length);
     T swappedData = SwapperNoOp::Swap(data[0]);
     _os.write( reinterpret_cast<const char*>(&swappedData), type_size);
     for(unsigned long i=1; i<length;++i) {
-      assert( _os );
+      xassert( _os );
       swappedData = SwapperNoOp::Swap(data[i]);
       _os.write( reinterpret_cast<const char*>(&swappedData), type_size );
     }
@@ -465,7 +465,7 @@ public:
     Internal[i] = sarray.substr(pos1, pos2-pos1);
     // Shouldn't we do the contrary, since we know how many separators
     // (and default behavior is to discard anything after the VM declared
-    assert( GetLength()-1 == i );
+    xassert( GetLength()-1 == i );
     }
 
   unsigned long GetLength() const {
@@ -524,9 +524,9 @@ public:
     if( len ) {
       if( len > Length ) {
         // perform realloc
-        assert( (len / size) * size == len );
+        xassert( (len / size) * size == len );
         Type *internal = new Type[len / size];
-        assert( Save == false );
+        xassert( Save == false );
         Save = true; // ????
         if( Internal )
           {
@@ -546,15 +546,15 @@ public:
     if( save ) {
       SetLength(len); // realloc
       memcpy(Internal, array, len/*/sizeof(Type)*/);
-      assert( Save == false );
+      xassert( Save == false );
       }
     else {
       // TODO rewrite this stupid code:
-      assert( Length == 0 );
-      assert( Internal == 0 );
-      assert( Save == false );
+      xassert( Length == 0 );
+      xassert( Internal == 0 );
+      xassert( Save == false );
       Length = len / sizeof(Type);
-      //assert( (len / sizeof(Type)) * sizeof(Type) == len );
+      //xassert( (len / sizeof(Type)) * sizeof(Type) == len );
       // MR00010001.dcm is a tough kid: 0019,105a is supposed to be VR::FL, VM::VM3 but
       // length is 14 bytes instead of 12 bytes. Simply consider value is total garbage.
       if( (len / sizeof(Type)) * sizeof(Type) != len ) { Internal = 0; Length = 0; }
@@ -563,15 +563,15 @@ public:
       Save = save;
   }
   void SetValue(typename VRToType<TVR>::Type v, unsigned int idx = 0) {
-    assert( idx < Length );
+    xassert( idx < Length );
     Internal[idx] = v;
   }
   const typename VRToType<TVR>::Type &GetValue(unsigned int idx = 0) const {
-    assert( idx < Length );
+    xassert( idx < Length );
     return Internal[idx];
   }
   typename VRToType<TVR>::Type &GetValue(unsigned int idx = 0) {
-    //assert( idx < Length );
+    //xassert( idx < Length );
     return Internal[idx];
   }
   typename VRToType<TVR>::Type operator[] (unsigned int idx) const {
@@ -579,13 +579,13 @@ public:
   }
   void Set(Value const &v) {
     const ByteValue *bv = dynamic_cast<const ByteValue*>(&v);
-    assert( bv ); // That would be bad...
+    xassert( bv ); // That would be bad...
     if( (VR::VRType)(VRToEncoding<TVR>::Mode) == VR::VRBINARY )
       {
       const Type* array = (Type*)bv->GetPointer();
       if( array ) {
-        assert( array ); // That would be bad...
-        assert( Internal == 0 );
+        xassert( array ); // That would be bad...
+        xassert( Internal == 0 );
         SetArray(array, bv->GetLength() ); }
       }
     else
@@ -622,8 +622,8 @@ public:
 
   // Implementation of Print is common to all Mode (ASCII/Binary)
   void Print(std::ostream &_os) const {
-    assert( Length );
-    assert( Internal );
+    xassert( Length );
+    xassert( Internal );
     _os << Internal[0]; // VM is at least garantee to be one
     const unsigned long length = GetLength() < 25 ? GetLength() : 25;
     for(unsigned long i=1; i<length; ++i)
@@ -647,7 +647,7 @@ public:
   DataElement GetAsDataElement() const {
     DataElement ret;
     ret.SetVR( (VR::VRType)TVR );
-    assert( ret.GetVR() != VR::SQ );
+    xassert( ret.GetVR() != VR::SQ );
     if( Internal )
       {
       std::ostringstream os;
@@ -684,13 +684,13 @@ public:
 protected:
   void SetNoSwap(Value const &v) {
     const ByteValue *bv = dynamic_cast<const ByteValue*>(&v);
-    assert( bv ); // That would be bad...
+    xassert( bv ); // That would be bad...
     if( (VR::VRType)(VRToEncoding<TVR>::Mode) == VR::VRBINARY )
       {
       const Type* array = (Type*)bv->GetPointer();
       if( array ) {
-        assert( array ); // That would be bad...
-        assert( Internal == 0 );
+        xassert( array ); // That would be bad...
+        xassert( Internal == 0 );
         SetArray(array, bv->GetLength() ); }
       }
     else
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.cxx
index aa13d49..0478c5e 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL ExplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -32,27 +32,26 @@ VL ExplicitDataElement::GetLength() const
     if( sq )
       {
       const VL sqlen = sq->ComputeLength<ExplicitDataElement>();
-      assert( sqlen % 2 == 0 );
+      xassert( sqlen % 2 == 0 );
       return TagField.GetLength() + VRField.GetLength() +
         ValueLengthField.GetLength() + sqlen;
       }
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & VR::OB_OW ); // VR::INVALID is not possible AFAIK...
+      xassert( VRField & VR::OB_OW ); // VR::INVALID is not possible AFAIK...
       const VL sflen = sf->ComputeLength();
-      assert( sflen % 2 == 0 );
+      xassert( sflen % 2 == 0 );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sflen;
       }
-    assert(0);
-    return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     const bool vr16bitsimpossible = (VRField & VR::VL16) && (ValueLengthField > (uint32_t)VL::GetVL16Max());
 
     if( vr16bitsimpossible || VRField == VR::INVALID )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.txx
index b5d32d2..9a5d4a7 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmExplicitDataElement.txx
@@ -43,7 +43,7 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !is.eof() ) // FIXME This should not be needed
       {
-      assert(0 && "Should not happen" );
+      throw Exception("Truncated file");
       }
     return is;
     }
@@ -53,14 +53,13 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
     pe.SetLastElement( *this );
     throw pe;
     }
-  //assert( TagField != Tag(0xfeff,0xdde0) );
+  //xassert( TagField != Tag(0xfeff,0xdde0) );
   const Tag itemDelItem(0xfffe,0xe00d);
   if( TagField == itemDelItem )
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( ValueLengthField )
       {
@@ -78,7 +77,7 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
   if( TagField == Tag(0x00ff, 0x4aa5) )
     {
-    //assert(0 && "Should not happen" );
+    //throw Exception("Structure error");
     // gdcmDataExtra/gdcmBreakers/DigitexAlpha_no_7FE0.dcm
     is.seekg( -4, std::ios::cur );
     TagField = Tag(0x7fe0,0x0010);
@@ -101,21 +100,20 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !VRField.Read(is) )
       {
-      assert(0 && "Should not happen" );
-      return is;
+      throw Exception("Truncated file");
       }
     }
   catch( Exception &ex )
     {
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
     // gdcm-MR-PHILIPS-16-Multi-Seq.dcm
-    // assert( TagField == Tag(0xfffe, 0xe000) );
+    // xassert( TagField == Tag(0xfffe, 0xe000) );
     // -> For some reason VR is written as {44,0} well I guess this is a VR...
     // Technically there is a second bug, dcmtk assume other things when reading this tag,
     // so I need to change this tag too, if I ever want dcmtk to read this file. oh well
     // 0019004_Baseline_IMG1.dcm
     // -> VR is garbage also...
-    // assert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
+    // xassert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
     //gdcmWarningMacro( "Assuming 16 bits VR for Tag=" <<
     //  TagField << " in order to read a buggy DICOM file." );
     //VRField = VR::INVALID;
@@ -132,8 +130,7 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     }
   else
@@ -141,8 +138,7 @@ std::istream &ExplicitDataElement::ReadPreValue(std::istream &is)
     // 16bits only
     if( !ValueLengthField.template Read16<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
     // HACK for SIEMENS Leonardo
@@ -188,11 +184,11 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
     }
 
   // Read the Value
-  //assert( ValueField == 0 );
+  //xassert( ValueField == 0 );
   if( VRField == VR::SQ )
     {
     // Check whether or not this is an undefined length sequence
-    assert( TagField != Tag(0x7fe0,0x0010) );
+    xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new SequenceOfItems;
     }
   else if( ValueLengthField.IsUndefined() )
@@ -200,7 +196,7 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
     if( TagField == Tag(0x7fe0,0x0010) )
       {
       // Ok this is Pixel Data fragmented...
-      assert( VRField & VR::OB_OW || VRField == VR::UN );
+      xassert( VRField & VR::OB_OW || VRField == VR::UN );
       ValueField = new SequenceOfFragments;
       }
     else
@@ -209,8 +205,8 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
       // Enhanced_MR_Image_Storage_PixelSpacingNotIn_0028_0030.dcm (illegal)
       // vs
       // undefined_length_un_vr.dcm
-      assert( TagField != Tag(0x7fe0,0x0010) );
-      assert( VRField == VR::UN );
+      xassert( TagField != Tag(0x7fe0,0x0010) );
+      xassert( VRField == VR::UN );
       ValueField = new SequenceOfItems;
       ValueField->SetLength(ValueLengthField); // perform realloc
       try
@@ -218,7 +214,7 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
         //if( !ValueIO<ExplicitDataElement,TSwap>::Read(is,*ValueField) ) // non cp246
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) ) // cp246 compliant
           {
-          assert(0);
+          throw Exception("Truncated file");
           }
         }
       catch( std::exception &)
@@ -235,7 +231,7 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
     }
   else
     {
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new ByteValue;
     }
   // We have the length we should be able to read the value
@@ -254,17 +250,17 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
   )
     {
     gdcmWarningMacro( "ByteSwaping Private SQ: " << TagField );
-    assert( VRField == VR::SQ );
-    assert( TagField.IsPrivate() );
+    xassert( VRField == VR::SQ );
+    xassert( TagField.IsPrivate() );
     try
       {
       if( !ValueIO<ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
         {
-        assert(0 && "Should not happen");
+        throw Exception("Truncated file");
         }
       Value* v = &*ValueField;
       SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(v);
-      assert( sq );
+      xassert( sq );
       SequenceOfItems::Iterator it = sq->Begin();
       for( ; it != sq->End(); ++it)
         {
@@ -283,17 +279,17 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
 #endif
 
   bool failed;
-  //assert( VRField != VR::UN );
+  //xassert( VRField != VR::UN );
   if( VRField & VR::VRASCII )
     {
-    //assert( VRField.GetSize() == 1 );
+    //xassert( VRField.GetSize() == 1 );
     failed = !ValueIO<ExplicitDataElement,TSwap>::Read(is,*ValueField,readvalues);
     }
   else
     {
-    assert( VRField & VR::VRBINARY );
+    xassert( VRField & VR::VRBINARY );
     unsigned int vrsize = VRField.GetSize();
-    assert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
+    xassert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
     if(VRField==VR::AT) vrsize = 2;
     switch(vrsize)
       {
@@ -311,7 +307,7 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
       break;
     default:
       failed = true;
-      assert(0);
+      throw Exception("Structure error");
       }
     }
   if( failed )
@@ -339,7 +335,7 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
   if( SequenceOfItems *sqi = dynamic_cast<SequenceOfItems*>(&GetValue()) )
     {
-    assert( ValueField->GetLength() == ValueLengthField );
+    xassert( ValueField->GetLength() == ValueLengthField );
     // Recompute the total length:
     if( !ValueLengthField.IsUndefined() )
       {
@@ -354,9 +350,9 @@ std::istream &ExplicitDataElement::ReadValue(std::istream &is, bool readvalues)
     }
   else if( SequenceOfFragments *sqf = dynamic_cast<SequenceOfFragments*>(&GetValue()) )
     {
-    assert( ValueField->GetLength() == ValueLengthField );
-    assert( sqf->GetLength() == ValueLengthField ); (void)sqf;
-    assert( ValueLengthField.IsUndefined() );
+    xassert( ValueField->GetLength() == ValueLengthField );
+    xassert( sqf->GetLength() == ValueLengthField ); (void)sqf;
+    xassert( ValueLengthField.IsUndefined() );
     }
 #endif
 
@@ -378,32 +374,12 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
   //if( TagField == Tag(0xfffe,0xe0dd) ) return os;
   if( !TagField.Write<TSwap>(os) )
     {
-    assert( 0 && "Should not happen" );
-    return os;
+    throw Exception("Writing error");
     }
   const Tag itemDelItem(0xfffe,0xe00d);
   if( TagField == itemDelItem )
     {
-    assert(0);
-    assert( ValueField == 0 );
-#ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
-    if( ValueLengthField != 0 )
-      {
-      gdcmWarningMacro(
-        "Item Delimitation Item had a length different from 0." );
-      VL zero = 0;
-      zero.Write<TSwap>(os);
-      return os;
-      }
-#endif
-    // else
-    assert( ValueLengthField == 0 );
-    if( !ValueLengthField.Write<TSwap>(os) )
-      {
-      assert( 0 && "Should not happen" );
-      return os;
-      }
-    return os;
+    throw Exception("Structure error");
     }
   bool vr16bitsimpossible = (VRField & VR::VL16) && (ValueLengthField > (uint32_t)VL::GetVL16Max());
   if( VRField == VR::INVALID || vr16bitsimpossible )
@@ -426,7 +402,7 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
       if( ValueField && dynamic_cast<const SequenceOfItems*>(&*ValueField) )
         {
         VL vl = 0xFFFFFFFF;
-        assert( vl.IsUndefined() );
+        xassert( vl.IsUndefined() );
         vl.Write<TSwap>(os);
         }
       else
@@ -435,18 +411,16 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
     }
   else
     {
-    assert( VRField.IsVRFile() && VRField != VR::INVALID );
+    xassert( VRField.IsVRFile() && VRField != VR::INVALID );
     if( !VRField.Write(os) )
       {
-      assert( 0 && "Should not happen" );
-      return os;
+      throw Exception("Writing error");
       }
     if( VRField & VR::VL32 )
       {
       if( !ValueLengthField.Write<TSwap>(os) )
         {
-        assert( 0 && "Should not happen" );
-        return os;
+        throw Exception("Writing error");
         }
       }
     else
@@ -454,8 +428,7 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
       // 16bits only
       if( !ValueLengthField.template Write16<TSwap>(os) )
         {
-        assert( 0 && "Should not happen" );
-        return os;
+        throw Exception("Writing error");
         }
       }
     }
@@ -470,12 +443,12 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
     // check consistency in Length:
     if( GetByteValue() )
       {
-      assert( ValueField->GetLength() == ValueLengthField );
+      xassert( ValueField->GetLength() == ValueLengthField );
       }
     //else if( GetSequenceOfItems() )
     else if( const SequenceOfItems *sqi = dynamic_cast<const SequenceOfItems*>(&GetValue()) )
       {
-      assert( ValueField->GetLength() == ValueLengthField );
+      xassert( ValueField->GetLength() == ValueLengthField );
       // Recompute the total length:
       if( !ValueLengthField.IsUndefined() )
         {
@@ -485,13 +458,13 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
       }
     else if( GetSequenceOfFragments() )
       {
-      assert( ValueField->GetLength() == ValueLengthField );
+      xassert( ValueField->GetLength() == ValueLengthField );
       }
 //#endif
     // We have the length we should be able to write the value
     if( VRField == VR::UN && ValueLengthField.IsUndefined() )
       {
-      assert( TagField == Tag(0x7fe0,0x0010) || GetValueAsSQ() );
+      xassert( TagField == Tag(0x7fe0,0x0010) || GetValueAsSQ() );
       ValueIO<ImplicitDataElement,TSwap>::Write(os,*ValueField);
       }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
@@ -522,9 +495,9 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
         }
       else
         {
-        assert( VRField & VR::VRBINARY );
+        xassert( VRField & VR::VRBINARY );
         unsigned int vrsize = VRField.GetSize();
-        assert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
+        xassert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
         if(VRField == VR::AT) vrsize = 2;
         switch(vrsize)
           {
@@ -542,12 +515,12 @@ const std::ostream &ExplicitDataElement::Write(std::ostream &os) const
           break;
         default:
           failed = true;
-          assert(0);
+          throw Exception("Structure error");
           }
         }
       if( failed )
         {
-        assert( 0 && "Should not happen" );
+        throw Exception("Structure error");
         }
       }
     }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.cxx
index e98a690..0bad3c5 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL ExplicitImplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -37,18 +37,17 @@ VL ExplicitImplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & (VR::OB | VR::OW) );
+      xassert( VRField & (VR::OB | VR::OW) );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
-    assert(0);
-  return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + 2*VRField.GetLength() + ValueLengthField;
     }
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.txx
index fafff32..acd80ac 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmExplicitImplicitDataElement.txx
@@ -44,7 +44,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !is.eof() ) // FIXME This should not be needed
       {
-      assert(0 && "Should not happen" );
+      throw Exception("Truncated file");
       }
     return is;
     }
@@ -54,7 +54,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     pe.SetLastElement( *this );
     throw pe;
     }
-  //assert( TagField != Tag(0xfeff,0xdde0) );
+  //xassert( TagField != Tag(0xfeff,0xdde0) );
   const Tag itemDelItem(0xfffe,0xe00d);
   if( TagField == itemDelItem )
     {
@@ -63,8 +63,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     //throw pe;
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( ValueLengthField )
       {
@@ -80,7 +79,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
   if( TagField == Tag(0x00ff, 0x4aa5) )
     {
-    //assert(0 && "Should not happen" );
+    //throw Exception("Structure error");
     // gdcmDataExtra/gdcmBreakers/DigitexAlpha_no_7FE0.dcm
     is.seekg( -4, std::ios::cur );
     TagField = Tag(0x7fe0,0x0010);
@@ -103,16 +102,14 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !VRField.Read(is) )
       {
-      assert(0 && "Should not happen" );
-      return is;
+      throw Exception("Truncated file");
       }
   // Read Value Length
   if( VR::GetLength(VRField) == 4 )
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     }
   else
@@ -120,8 +117,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     // 16bits only
     if( !ValueLengthField.template Read16<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
     // HACK for SIEMENS Leonardo
@@ -145,13 +141,11 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
   const Tag itemStartItem(0xfffe,0xe000);
   if( TagField == itemStartItem ) return is;
 
-  //assert( TagField != Tag(0xfffe,0xe0dd) );
+  //xassert( TagField != Tag(0xfffe,0xe0dd) );
   // Read Value Length
   if( !ValueLengthField.Read<TSwap>(is) )
     {
-    //assert(0 && "Should not happen");
-    throw Exception("Impossible");
-    return is;
+    throw Exception("Truncated file");
     }
   //std::cerr << "imp cur tag=" << TagField <<  " VL=" << ValueLengthField << std::endl;
   if( ValueLengthField == 0 )
@@ -162,9 +156,9 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
     }
   else if( ValueLengthField.IsUndefined() )
     {
-    //assert( de.GetVR() == VR::SQ );
+    //xassert( de.GetVR() == VR::SQ );
     // FIXME what if I am reading the pixel data...
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     if( TagField != Tag(0x7fe0,0x0010) )
       {
       ValueField = new SequenceOfItems;
@@ -202,7 +196,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
       is.seekg(-4, std::ios::cur );
       if( item == itemStart )
         {
-        assert( TagField != Tag(0x7fe0,0x0010) );
+        xassert( TagField != Tag(0x7fe0,0x0010) );
         ValueField = new SequenceOfItems;
         }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
@@ -219,7 +213,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
           {
           if( !ValueIO<ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,true) )
             {
-            assert(0 && "Should not happen");
+            throw Exception("Truncated file");
             }
           }
         catch( std::exception &ex2 )
@@ -237,7 +231,7 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
         ValueField->SetLength(ValueLengthField); // perform realloc
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,true) )
           {
-          assert(0 && "Should not happen");
+          throw Exception("Truncated file");
           }
         return is;
         }
@@ -299,12 +293,12 @@ std::istream &ExplicitImplicitDataElement::ReadPreValue(std::istream &is)
   VL dummy = ValueField->GetLength();
   if( ValueLengthField != dummy )
     {
-    gdcmWarningMacro( "ValueLengthField was bogus" ); assert(0);
+    gdcmWarningMacro( "ValueLengthField was bogus" ); throw Exception("Structure error");
     ValueLengthField = dummy;
     }
 #else
-  assert( ValueLengthField == ValueField->GetLength() );
-  assert( VRField == VR::INVALID );
+  xassert( ValueLengthField == ValueField->GetLength() );
+  xassert( VRField == VR::INVALID );
 #endif
 
   return is;
@@ -349,11 +343,11 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
     }
 
   // Read the Value
-  //assert( ValueField == 0 );
+  //xassert( ValueField == 0 );
   if( VRField == VR::SQ )
     {
     // Check whether or not this is an undefined length sequence
-    assert( TagField != Tag(0x7fe0,0x0010) );
+    xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new SequenceOfItems;
     }
   else if( ValueLengthField.IsUndefined() )
@@ -364,7 +358,7 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
       // Enhanced_MR_Image_Storage_PixelSpacingNotIn_0028_0030.dcm (illegal)
       // vs
       // undefined_length_un_vr.dcm
-      assert( TagField != Tag(0x7fe0,0x0010) );
+      xassert( TagField != Tag(0x7fe0,0x0010) );
       ValueField = new SequenceOfItems;
       ValueField->SetLength(ValueLengthField); // perform realloc
       try
@@ -372,7 +366,7 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
         //if( !ValueIO<ExplicitDataElement,TSwap>::Read(is,*ValueField) ) // non cp246
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) ) // cp246 compliant
           {
-          assert(0);
+          throw Exception("Truncated file");
           }
         }
       catch( std::exception &)
@@ -389,14 +383,14 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
     else
       {
       // Ok this is Pixel Data fragmented...
-      assert( TagField == Tag(0x7fe0,0x0010) );
-      assert( VRField & VR::OB_OW );
+      xassert( TagField == Tag(0x7fe0,0x0010) );
+      xassert( VRField & VR::OB_OW );
       ValueField = new SequenceOfFragments;
       }
     }
   else
     {
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new ByteValue;
     }
   // We have the length we should be able to read the value
@@ -415,17 +409,17 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
   )
     {
     gdcmWarningMacro( "ByteSwaping Private SQ: " << TagField );
-    assert( VRField == VR::SQ );
-    assert( TagField.IsPrivate() );
+    xassert( VRField == VR::SQ );
+    xassert( TagField.IsPrivate() );
     try
       {
       if( !ValueIO<ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
         {
-        assert(0 && "Should not happen");
+        throw Exception("Truncated file");
         }
       Value* v = &*ValueField;
       SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(v);
-      assert( sq );
+      xassert( sq );
       SequenceOfItems::Iterator it = sq->Begin();
       for( ; it != sq->End(); ++it)
         {
@@ -444,17 +438,17 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
 #endif
 
   bool failed;
-  //assert( VRField != VR::UN );
+  //xassert( VRField != VR::UN );
   if( VRField & VR::VRASCII )
     {
-    //assert( VRField.GetSize() == 1 );
+    //xassert( VRField.GetSize() == 1 );
     failed = !ValueIO<ExplicitDataElement,TSwap>::Read(is,*ValueField,readvalues);
     }
   else
     {
-    assert( VRField & VR::VRBINARY );
+    xassert( VRField & VR::VRBINARY );
     unsigned int vrsize = VRField.GetSize();
-    assert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
+    xassert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
     if(VRField==VR::AT) vrsize = 2;
     switch(vrsize)
       {
@@ -472,7 +466,7 @@ std::istream &ExplicitImplicitDataElement::ReadValue(std::istream &is, bool read
       break;
     default:
     failed = true;
-      assert(0);
+      throw Exception("Structure error");
       }
     }
   if( failed )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmFile.cxx b/Source/DataStructureAndEncodingDefinition/gdcmFile.cxx
index 01ace66..a6ec776 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmFile.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmFile.cxx
@@ -22,14 +22,12 @@ File::~File() {}
 
 std::istream &File::Read(std::istream &is)
 {
-  assert(0);
-  return is;
+  throw Exception("Truncated file");
 }
 
 std::ostream const &File::Write(std::ostream &os) const
 {
-  assert(0);
-  return os;
+  throw Exception("Writing error");
 }
 
 } // end namespace gdcm_ns
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmFile.h b/Source/DataStructureAndEncodingDefinition/gdcmFile.h
index f7d0b29..c414062 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmFile.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmFile.h
@@ -71,8 +71,7 @@ inline std::ostream& operator<<(std::ostream &os, const File &val)
 {
   os << val.GetHeader() << std::endl;
   //os << val.GetDataSet() << std::endl; // FIXME
-  assert(0);
-  return os;
+  throw Exception("Writing error");
 }
 
 } // end namespace gdcm_ns
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmFileMetaInformation.cxx b/Source/DataStructureAndEncodingDefinition/gdcmFileMetaInformation.cxx
index b2687ad..7603e91 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmFileMetaInformation.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmFileMetaInformation.cxx
@@ -189,7 +189,7 @@ void FileMetaInformation::FillFromDataSet(DataSet const &ds)
         {
         const DataElement& sopclass = ds.GetDataElement( Tag(0x0008, 0x0016) );
         DataElement mssopclass = GetDataElement( Tag(0x0002, 0x0002) );
-        assert( !mssopclass.IsEmpty() );
+        xassert( !mssopclass.IsEmpty() );
         const ByteValue *bv = sopclass.GetByteValue();
         if( bv )
           {
@@ -232,7 +232,7 @@ void FileMetaInformation::FillFromDataSet(DataSet const &ds)
       }
     else
       {
-      //assert(0);
+      //throw Exception("Structure error");
       throw gdcm::Exception( "No 2,3 and 8,18 element sorry" );
       }
     }
@@ -247,26 +247,26 @@ void FileMetaInformation::FillFromDataSet(DataSet const &ds)
       if( !ds.FindDataElement( Tag(0x0008, 0x0018) ) || ds.GetDataElement( Tag(0x0008, 0x0018) ).IsEmpty() )
         {
         throw gdcm::Exception( "No 8,18 element sorry" );
-        //assert(0);
+        //throw Exception("Structure error");
         }
       const DataElement& sopinst = ds.GetDataElement( Tag(0x0008, 0x0018) );
       //const DataElement & foo = GetDataElement( Tag(0x0002, 0x0003) );
-      assert( !GetDataElement( Tag(0x0002, 0x0003) ).IsEmpty() );
+      xassert( !GetDataElement( Tag(0x0002, 0x0003) ).IsEmpty() );
       DataElement mssopinst = GetDataElement( Tag(0x0002, 0x0003) );
       const ByteValue *bv = sopinst.GetByteValue();
-      assert( bv );
+      xassert( bv );
       mssopinst.SetByteValue( bv->GetPointer(), bv->GetLength() );
       Replace( mssopinst );
       }
     }
-  //assert( !GetDataElement( Tag(0x0002,0x0003) ).IsEmpty() );
+  //xassert( !GetDataElement( Tag(0x0002,0x0003) ).IsEmpty() );
   // Transfer Syntax UID (0002,0010) -> ??? (computed at write time at most)
   if( FindDataElement( Tag(0x0002, 0x0010) ) && !GetDataElement( Tag(0x0002,0x0010) ).IsEmpty() )
     {
     DataElement tsuid = GetDataElement( Tag(0x0002, 0x0010) );
     const char * datasetts = DataSetTS.GetString();
     const ByteValue * bv = tsuid.GetByteValue();
-    assert( bv );
+    xassert( bv );
     std::string currentts( bv->GetPointer(), bv->GetPointer() + bv->GetLength() );
     if( strlen(currentts.c_str()) != strlen(datasetts)
       || strcmp( currentts.c_str(), datasetts ) != 0 )
@@ -315,7 +315,7 @@ void FileMetaInformation::FillFromDataSet(DataSet const &ds)
     // TODO: Need to check Implementation UID is actually a valid UID...
     //const DataElement& impuid = GetDataElement( Tag(0x0002, 0x0012) );
     //const ByteValue *bv = impuid.GetByteValue();
-    //assert( bv );
+    //xassert( bv );
     //std::string copy( bv->GetPointer(), bv->GetLength() );
     //if( !UIDGenerator::IsValid( copy.c_str() ) )
     //  {
@@ -350,11 +350,11 @@ void FileMetaInformation::FillFromDataSet(DataSet const &ds)
   Attribute<0x0002, 0x0000> filemetagrouplength;
   Remove( filemetagrouplength.GetTag() );
   unsigned int glen = GetLength<ExplicitDataElement>();
-  assert( (glen % 2) == 0 );
+  xassert( (glen % 2) == 0 );
   filemetagrouplength.SetValue( glen );
   Insert( filemetagrouplength.GetAsDataElement() );
 
-  assert( !IsEmpty() );
+  xassert( !IsEmpty() );
 }
 
 // FIXME
@@ -371,8 +371,7 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
   Tag t;
   if( !t.template Read<TSwap>(is) )
     {
-    assert(0 && "Should not happen" );
-    return false;
+    throw Exception("Truncated file");
     }
   //std::cout << "Tag: " << t << std::endl;
   if( t.GetGroup() != 0x0002 )
@@ -383,8 +382,8 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
     // which seems to be quite different than fseeking in reverse from
     // the current position... ???
     //is.seekg( start, std::ios::beg );
-    assert( (start - currentpos) <= 0);
-    assert( (int)(start - currentpos) == -4 );
+    xassert( (start - currentpos) <= 0);
+    xassert( (int)(start - currentpos) == -4 );
     is.seekg( (start - currentpos), std::ios::cur );
     return false;
     }
@@ -402,8 +401,7 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
     {
     if( !vl.template Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return false;
+      throw Exception("Truncated file");
       }
     }
   else
@@ -416,13 +414,11 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
   ByteValue *bv = NULL;
   if( vr == VR::SQ )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Structure error");
     }
   else if( vl.IsUndefined() )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Structure error");
     }
   else
     {
@@ -432,13 +428,12 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
   bv->SetLength(vl); // perform realloc
   if( !bv->template Read<TSwap>(is) )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Truncated file");
     }
   //std::cout << "Value : ";
   //bv->Print( std::cout );
   //std::cout << std::endl;
-  assert( bv->GetLength() == vl );
+  xassert( bv->GetLength() == vl );
 
   de.SetTag(t);
   de.SetVR(vr);
@@ -448,7 +443,7 @@ bool ReadExplicitDataElement(std::istream &is, ExplicitDataElement &de)
 
 //  if( vl == 0 )
 //    {
-//    assert( de.IsEmpty() );
+//    xassert( de.IsEmpty() );
 //    }
 
   return true;
@@ -463,8 +458,7 @@ bool ReadImplicitDataElement(std::istream &is, ImplicitDataElement &de)
   Tag t;
   if( !t.template Read<TSwap>(is) )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Truncated file");
     }
   //std::cout << "Tag: " << t << std::endl;
   if( t.GetGroup() != 0x0002 )
@@ -477,14 +471,12 @@ bool ReadImplicitDataElement(std::istream &is, ImplicitDataElement &de)
   VL vl;
   if( !vl.template Read<TSwap>(is) )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Truncated file");
     }
   ByteValue *bv = 0;
   if( vl.IsUndefined() )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Structure error");
     }
   else
     {
@@ -494,8 +486,7 @@ bool ReadImplicitDataElement(std::istream &is, ImplicitDataElement &de)
   bv->SetLength(vl); // perform realloc
   if( !bv->template Read<TSwap>(is) )
     {
-    assert(0 && "Should not happen");
-    return false;
+    throw Exception("Truncated file");
     }
   de.SetTag(t);
   de.SetVL(vl);
@@ -560,7 +551,7 @@ std::istream &FileMetaInformation::Read(std::istream &is)
 std::istream &FileMetaInformation::ReadCompat(std::istream &is)
 {
   // \precondition
-  assert( is.good() );
+  xassert( is.good() );
   // First off save position in case we fail (no File Meta Information)
   // See PS 3.5, Data Element Structure With Explicit VR
   if( !IsEmpty() )
@@ -631,7 +622,7 @@ std::istream &FileMetaInformation::ReadCompat(std::istream &is)
     }
   else
     {
-    //assert( t.GetElement() == 0x0 );
+    //xassert( t.GetElement() == 0x0 );
     char vr_str[3];
     VR::VRType vr = VR::VR_END;
     if( is.read(vr_str, 2) )
@@ -663,7 +654,7 @@ std::istream &FileMetaInformation::ReadCompat(std::istream &is)
         // something like IM-0001-0066.CommandTag00.dcm was crafted
         ide.ReadValue<SwapperNoOp>(is);
         ReadCompat(is); // this will read the next element
-        assert( DataSetTS == TransferSyntax::ImplicitVRLittleEndian );
+        xassert( DataSetTS == TransferSyntax::ImplicitVRLittleEndian );
         is.seekg(-12, std::ios::cur); // Seek back
         return is;
         }
@@ -702,7 +693,7 @@ bool AddVRToDataElement(DataElement &de)
 template <typename TSwap>
 std::istream &FileMetaInformation::ReadCompatInternal(std::istream &is)
 {
-  //assert( t.GetGroup() == 0x0002 );
+  //xassert( t.GetGroup() == 0x0002 );
 //  if( t.GetGroup() == 0x0002 )
     {
     // Purposely not Re-use ReadVR since we can read VR_END
@@ -766,7 +757,7 @@ std::istream &FileMetaInformation::ReadCompatInternal(std::istream &is)
 
 //void FileMetaInformation::SetTransferSyntaxType(TS const &ts)
 //{
-//  //assert( DS == 0 );
+//  //xassert( DS == 0 );
 //  //InternalTS = ts;
 //}
 
@@ -816,7 +807,7 @@ std::string FileMetaInformation::GetMediaStorageAsString() const
   std::string ts;
     {
     const ByteValue *bv = de.GetByteValue();
-    assert( bv );
+    xassert( bv );
     if( bv->GetPointer() && bv->GetLength() )
       {
       // Pad string with a \0
@@ -876,7 +867,7 @@ std::ostream &FileMetaInformation::Write(std::ostream &os) const
   }
 //  else
 //  {
-//    assert(0);
+//    throw Exception("Write error");
 //  }
 #if 0
     // At least make sure to have group length
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmFragment.cxx b/Source/DataStructureAndEncodingDefinition/gdcmFragment.cxx
index 537a509..7b263ac 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmFragment.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmFragment.cxx
@@ -18,8 +18,8 @@ namespace gdcm_ns
 
 VL Fragment::GetLength() const
 {
-  assert( !ValueLengthField.IsUndefined() );
-  assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+  xassert( !ValueLengthField.IsUndefined() );
+  xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
   return TagField.GetLength() + ValueLengthField.GetLength()
     + ValueLengthField;
 }
@@ -27,9 +27,9 @@ VL Fragment::GetLength() const
 VL Fragment::ComputeLength() const
 {
   const ByteValue *bv = GetByteValue();
-  assert( bv );
-  assert( !ValueLengthField.IsUndefined() );
-  //assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+  xassert( bv );
+  xassert( !ValueLengthField.IsUndefined() );
+  //xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
   return TagField.GetLength() + ValueLengthField.GetLength()
     + bv->ComputeLength() /*ValueLengthField*/;
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmFragment.h b/Source/DataStructureAndEncodingDefinition/gdcmFragment.h
index 42a88b3..1fc5c89 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmFragment.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmFragment.h
@@ -126,7 +126,7 @@ public:
     while( cont )
       {
       TagField.Read<TSwap>(is);
-      assert( is );
+      xassert( is );
       if( TagField != itemStart && TagField != seqDelItem )
         {
         ++offset;
@@ -144,7 +144,7 @@ public:
         cont = false;
         }
       }
-    assert( TagField == itemStart || TagField == seqDelItem );
+    xassert( TagField == itemStart || TagField == seqDelItem );
     if( !ValueLengthField.Read<TSwap>(is) )
       {
       return is;
@@ -175,10 +175,9 @@ public:
     const Tag seqDelItem(0xfffe,0xe0dd);
     if( !TagField.Write<TSwap>(os) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
-    assert( TagField == itemStart
+    xassert( TagField == itemStart
          || TagField == seqDelItem );
     const ByteValue *bv = GetByteValue();
     // VL
@@ -186,36 +185,33 @@ public:
     // CompressedLossy.dcm
     if( IsEmpty() )
       {
-      //assert( bv );
+      //xassert( bv );
       VL zero = 0;
       if( !zero.Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     else
       {
-      assert( ValueLengthField );
-      assert( !ValueLengthField.IsUndefined() );
+      xassert( ValueLengthField );
+      xassert( !ValueLengthField.IsUndefined() );
       const VL actuallen = bv->ComputeLength();
-      assert( actuallen == ValueLengthField || actuallen == ValueLengthField + 1 );
+      xassert( actuallen == ValueLengthField || actuallen == ValueLengthField + 1 );
       if( !actuallen.Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     // Value
     if( ValueLengthField && bv )
       {
       // Self
-      assert( bv );
-      assert( bv->GetLength() == ValueLengthField );
+      xassert( bv );
+      xassert( bv->GetLength() == ValueLengthField );
       if( !bv->Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     return os;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.cxx
index 0cf211d..9d73713 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.cxx
@@ -23,7 +23,7 @@ VL ImplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
     if( sq )
@@ -35,12 +35,12 @@ VL ImplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      //assert( VRField & VR::OB_OW ); // VR::INVALID is not possible AFAIK...
+      //xassert( VRField & VR::OB_OW ); // VR::INVALID is not possible AFAIK...
       return TagField.GetLength() /*+ VRField.GetLength()*/
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
 #endif
-    assert( !ValueLengthField.IsUndefined() );
+    xassert( !ValueLengthField.IsUndefined() );
     return ValueLengthField;
     }
   //else if( const SequenceOfItems *sqi = GetSequenceOfItems() )
@@ -52,7 +52,7 @@ VL ImplicitDataElement::GetLength() const
     }
   else
     {
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + ValueLengthField.GetLength()
       + ValueLengthField;
     }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.txx
index 6aebef5..f639d55 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmImplicitDataElement.txx
@@ -41,19 +41,16 @@ std::istream &ImplicitDataElement::ReadPreValue(std::istream& is)
   if( !is )
     {
     if( !is.eof() ) // FIXME This should not be needed
-      assert(0 && "Should not happen");
-    return is;
+      throw Exception("Truncated file");
     }
   const Tag itemStartItem(0xfffe,0xe000);
   if( TagField == itemStartItem ) return is;
 
-  //assert( TagField != Tag(0xfffe,0xe0dd) );
+  //xassert( TagField != Tag(0xfffe,0xe0dd) );
   // Read Value Length
   if( !ValueLengthField.Read<TSwap>(is) )
     {
-    //assert(0 && "Should not happen");
-    throw Exception("Impossible ValueLengthField");
-    return is;
+    throw Exception("Truncated file");
     }
   return is;
 }
@@ -63,7 +60,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
 {
   if( is.eof() ) return is;
   const Tag itemStartItem(0xfffe,0xe000);
-  assert( TagField != itemStartItem );
+  xassert( TagField != itemStartItem );
 
   /*
    * technically this should not be needed, but what if an implementor, forgot
@@ -93,9 +90,9 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
     }
   else if( ValueLengthField.IsUndefined() )
     {
-    //assert( de.GetVR() == VR::SQ );
+    //xassert( de.GetVR() == VR::SQ );
     // FIXME what if I am reading the pixel data...
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     if( TagField != Tag(0x7fe0,0x0010) )
       {
       ValueField = new SequenceOfItems;
@@ -133,7 +130,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
       is.seekg(-4, std::ios::cur );
       if( item == itemStart )
         {
-        assert( TagField != Tag(0x7fe0,0x0010) );
+        xassert( TagField != Tag(0x7fe0,0x0010) );
         ValueField = new SequenceOfItems;
         }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
@@ -150,7 +147,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
           {
           if( !ValueIO<ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
             {
-            assert(0 && "Should not happen");
+            throw Exception("Truncated file");
             }
           gdcmWarningMacro( "Illegal: Explicit SQ found in a file with "
             "TransferSyntax=Implicit for tag: " << TagField );
@@ -161,7 +158,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
           std::streampos current = is.tellg();
           std::streamoff diff = start - current;
           is.seekg( diff, std::ios::cur );
-          assert( diff == -14 );
+          xassert( diff == -14 );
           ValueIO<ImplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues);
           }
         catch( std::exception & )
@@ -178,7 +175,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
         ValueField->SetLength(ValueLengthField); // perform realloc
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) )
           {
-          assert(0 && "Should not happen");
+          throw Exception("Truncated file");
           }
         return is;
         }
@@ -222,14 +219,14 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
   VR vrfield = GetVRFromTag( TagField );
   if( vrfield & VR::VRASCII || vrfield == VR::INVALID )
     {
-    //assert( VRField.GetSize() == 1 );
+    //xassert( VRField.GetSize() == 1 );
     failed = !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues);
     }
   else
     {
-    assert( vrfield & VR::VRBINARY );
+    xassert( vrfield & VR::VRBINARY );
     unsigned int vrsize = vrfield.GetSize();
-    assert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
+    xassert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
     if(vrfield==VR::AT) vrsize = 2;
     switch(vrsize)
       {
@@ -247,7 +244,7 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
       break;
     default:
     failed = true;
-      assert(0);
+      throw Exception("Structure error");
       }
     }
 #else
@@ -276,12 +273,12 @@ std::istream &ImplicitDataElement::ReadValue(std::istream &is, bool readvalues)
   VL dummy = ValueField->GetLength();
   if( ValueLengthField != dummy )
     {
-    gdcmWarningMacro( "ValueLengthField was bogus" ); assert(0);
+    gdcmWarningMacro( "ValueLengthField was bogus" ); throw Exception("Structure error");
     ValueLengthField = dummy;
     }
 #else
-  assert( ValueLengthField == ValueField->GetLength() );
-  assert( VRField == VR::INVALID );
+  xassert( ValueLengthField == ValueField->GetLength() );
+  xassert( VRField == VR::INVALID );
 #endif
 
   return is;
@@ -330,9 +327,9 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
     }
   else if( ValueLengthField.IsUndefined() )
     {
-    //assert( de.GetVR() == VR::SQ );
+    //xassert( de.GetVR() == VR::SQ );
     // FIXME what if I am reading the pixel data...
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     if( TagField != Tag(0x7fe0,0x0010) )
       {
       ValueField = new SequenceOfItems;
@@ -370,7 +367,7 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
       is.seekg(-4, std::ios::cur );
       if( item == itemStart )
         {
-        assert( TagField != Tag(0x7fe0,0x0010) );
+        xassert( TagField != Tag(0x7fe0,0x0010) );
         ValueField = new SequenceOfItems;
         }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
@@ -387,7 +384,7 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
           {
           if( !ValueIO<ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
             {
-            assert(0 && "Should not happen");
+            throw Exception("Truncated file");
             }
           gdcmWarningMacro( "Illegal: Explicit SQ found in a file with "
             "TransferSyntax=Implicit for tag: " << TagField );
@@ -398,7 +395,7 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
           std::streampos current = is.tellg();
           std::streamoff diff = start - current;//could be bad, if the specific implementation does not support negative streamoff values.
           is.seekg( diff, std::ios::cur );
-          assert( diff == -14 );
+          xassert( diff == -14 );
           ValueIO<ImplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues);
           }
         catch( std::exception & )
@@ -409,14 +406,14 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
         }
       else if ( item == itemPMSStart2 )
         {
-        assert( 0 ); // FIXME: Sync Read/ReadWithLength
+        throw Exception("Structure error");// FIXME: Sync Read/ReadWithLength
         gdcmWarningMacro( "Illegal: SQ start with " << itemPMSStart2
           << " instead of " << itemStart << " for tag: " << TagField );
         ValueField = new SequenceOfItems;
         ValueField->SetLength(ValueLengthField); // perform realloc
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) )
           {
-          assert(0 && "Should not happen");
+          throw Exception("Truncated file");
           }
         return is;
         }
@@ -460,14 +457,14 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
   VR vrfield = GetVRFromTag( TagField );
   if( vrfield & VR::VRASCII || vrfield == VR::INVALID )
     {
-    //assert( VRField.GetSize() == 1 );
+    //xassert( VRField.GetSize() == 1 );
     failed = !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues);
     }
   else
     {
-    assert( vrfield & VR::VRBINARY );
+    xassert( vrfield & VR::VRBINARY );
     unsigned int vrsize = vrfield.GetSize();
-    assert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
+    xassert( vrsize == 1 || vrsize == 2 || vrsize == 4 || vrsize == 8 );
     if(vrfield==VR::AT) vrsize = 2;
     switch(vrsize)
       {
@@ -485,7 +482,7 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
       break;
     default:
     failed = true;
-      assert(0);
+      throw Exception("Structure error");
       }
     }
 #else
@@ -519,8 +516,8 @@ std::istream &ImplicitDataElement::ReadValueWithLength(std::istream& is, VL & le
     ValueLengthField = dummy;
     }
 #else
-  assert( ValueLengthField == ValueField->GetLength() );
-  assert( VRField == VR::INVALID );
+  xassert( ValueLengthField == ValueField->GetLength() );
+  xassert( VRField == VR::INVALID );
 #endif
 
   return is;
@@ -534,8 +531,7 @@ const std::ostream &ImplicitDataElement::Write(std::ostream &os) const
   // Write Tag
   if( !TagField.Write<TSwap>(os) )
     {
-    assert(0 && "Should not happen");
-    return os;
+    throw Exception("Writing error");
     }
   // Write Value Length
   const SequenceOfItems *sqi = dynamic_cast<const SequenceOfItems*>( ValueField.GetPointer() ); //GetSequenceOfItems();
@@ -544,11 +540,10 @@ const std::ostream &ImplicitDataElement::Write(std::ostream &os) const
     // Hum, we might have to recompute the length:
     // See TestWriter2, where an explicit SQ is converted to implicit SQ
     VL len = sqi->template ComputeLength<ImplicitDataElement>();
-    //assert( len == ValueLengthField );
+    //xassert( len == ValueLengthField );
     if( !len.Write<TSwap>(os) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
     }
   else // It should be safe to simply use the ValueLengthField as stored:
@@ -557,21 +552,19 @@ const std::ostream &ImplicitDataElement::Write(std::ostream &os) const
     if( TagField == Tag(0x7fe0,0x0010) && ValueLengthField.IsUndefined() ) throw Exception( "VL u/f Impossible" );
     if( !ValueLengthField.Write<TSwap>(os) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
     }
   // Write Value
   if( ValueLengthField )
     {
-    assert( ValueField );
+    xassert( ValueField );
     gdcmAssertAlwaysMacro( ValueLengthField == ValueField->GetLength() );
-    assert( TagField != Tag(0xfffe, 0xe00d)
+    xassert( TagField != Tag(0xfffe, 0xe00d)
          && TagField != Tag(0xfffe, 0xe0dd) );
     if( !ValueIO<ImplicitDataElement,TSwap>::Write(os,*ValueField) )
       {
-      assert(0 && "Should not happen");
-      return os;
+      throw Exception("Writing error");
       }
     }
   return os;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmItem.h b/Source/DataStructureAndEncodingDefinition/gdcmItem.h
index 74bc1d4..35dfb00 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmItem.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmItem.h
@@ -61,7 +61,7 @@ public:
     // Update the length
     if( !IsUndefinedLength() )
       {
-      assert( 0 && "InsertDataElement" );
+      throw Exception("Structure error");
       //ValueLengthField += de.GetLength();
       }
     }
@@ -99,11 +99,11 @@ public:
     {
         DataSet &nested = NestedDataSet;
         nested.Clear();
-        assert( nested.IsEmpty() );
+        xassert( nested.IsEmpty() );
     }
     if( !TagField.Read<TSwap>(is) )
       {
-      throw Exception("Should not happen (item)");
+      throw Exception("Truncated file");
       return is;
       }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
@@ -114,13 +114,12 @@ public:
       gdcmWarningMacro( "ByteSwaping Private SQ: " << TagField );
       // Invert previously read TagField since wrong endianness:
       TagField = Tag( SwapperDoOp::Swap( TagField.GetGroup() ), SwapperDoOp::Swap( TagField.GetElement() ) );
-      assert ( TagField == Tag(0xfffe, 0xe000)
+      xassert ( TagField == Tag(0xfffe, 0xe000)
         || TagField == Tag(0xfffe, 0xe0dd) );
 
       if( !ValueLengthField.Read<SwapperDoOp>(is) )
         {
-        assert(0 && "Should not happen");
-        return is;
+        throw Exception("Truncated file");
         }
       // Self
       // Some file written by GDCM 1.0 we writting 0xFFFFFFFF instead of 0x0
@@ -133,7 +132,7 @@ public:
         }
       //else if( ValueLengthField == 0 )
       //  {
-      //  //assert( TagField == Tag( 0xfffe, 0xe0dd) );
+      //  //xassert( TagField == Tag( 0xfffe, 0xe0dd) );
       //  if( TagField != Tag( 0xfffe, 0xe0dd) )
       //    {
       //    gdcmErrorMacro( "SQ: " << TagField << " has a length of 0" );
@@ -143,7 +142,7 @@ public:
         {
         DataSet &nested = NestedDataSet;
         nested.Clear();
-        assert( nested.IsEmpty() );
+        xassert( nested.IsEmpty() );
         std::streampos start = is.tellg();
         try
           {
@@ -158,7 +157,7 @@ public:
           // You have to byteswap the length but not the tag...sigh
           gdcmWarningMacro( "Attempt to read nested Item without byteswapping the Value Length." );
           start -= is.tellg();
-          assert( start < 0 );
+          xassert( start < 0 );
           is.seekg( start, std::ios::cur );
           nested.Clear();
           nested.template ReadNested<TDE,SwapperNoOp>(is);
@@ -174,14 +173,14 @@ public:
           }
         catch(...)
           {
-          assert(0);
+          throw Exception("Structure error");
           }
         }
       else /* if( ValueLengthField.IsUndefined() ) */
         {
         DataSet &nested = NestedDataSet;
         nested.Clear();
-        assert( nested.IsEmpty() );
+        xassert( nested.IsEmpty() );
         nested.template ReadWithLength<TDE,SwapperDoOp>(is, ValueLengthField);
         ByteSwapFilter bsf(nested);
         bsf.ByteSwap();
@@ -200,12 +199,11 @@ public:
       gdcmDebugMacro( "Invalid Item, found tag: " << TagField);
       throw Exception( "Not a valid Item" );
       }
-    assert( TagField == Tag(0xfffe, 0xe000) || TagField == Tag(0xfffe, 0xe0dd) );
+    xassert( TagField == Tag(0xfffe, 0xe000) || TagField == Tag(0xfffe, 0xe0dd) );
 
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     // Self
     if( TagField == Tag(0xfffe,0xe0dd) )
@@ -220,15 +218,15 @@ public:
       {
       DataSet &nested = NestedDataSet;
       nested.Clear();
-      assert( nested.IsEmpty() );
+      xassert( nested.IsEmpty() );
       nested.template ReadNested<TDE,TSwap>(is);
       }
     else /* if( ValueLengthField.IsUndefined() ) */
       {
-      assert( !ValueLengthField.IsUndefined() );
+      xassert( !ValueLengthField.IsUndefined() );
       DataSet &nested = NestedDataSet;
       nested.Clear();
-      assert( nested.IsEmpty() );
+      xassert( nested.IsEmpty() );
       nested.template ReadWithLength<TDE,TSwap>(is, ValueLengthField);
       }
 
@@ -246,38 +244,35 @@ public:
     else
 #endif
       {
-      assert ( TagField == Tag(0xfffe, 0xe000)
+      xassert ( TagField == Tag(0xfffe, 0xe000)
         || TagField == Tag(0xfffe, 0xe0dd) );
       // Not sure how this happen
       if( TagField == Tag(0xfffe, 0xe0dd) )
         {
         gdcmWarningMacro( "SegDelItem found in defined length Sequence" );
-        assert( ValueLengthField == 0 );
-        assert( NestedDataSet.Size() == 0 );
+        xassert( ValueLengthField == 0 );
+        xassert( NestedDataSet.Size() == 0 );
         }
       if( !TagField.Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     if( ValueLengthField.IsUndefined() )
       {
       if( !ValueLengthField.Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     else
       {
       const VL dummy = NestedDataSet.GetLength<TDE>();
-      assert( dummy % 2 == 0 );
-      //assert( ValueLengthField == dummy );
+      xassert( dummy % 2 == 0 );
+      //xassert( ValueLengthField == dummy );
       if( !dummy.Write<TSwap>(os) )
         {
-        assert(0 && "Should not happen");
-        return os;
+        throw Exception("Writing error");
         }
       }
     // Self
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmItem.txx b/Source/DataStructureAndEncodingDefinition/gdcmItem.txx
index d71357e..9ce60c7 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmItem.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmItem.txx
@@ -24,13 +24,13 @@ VL Item::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( !NestedDataSet.GetLength<TDE>().IsUndefined() );
+    xassert( !NestedDataSet.GetLength<TDE>().IsUndefined() );
     // Item Start             4
     // Item Length            4
     // DataSet                ?
     // Item End Delimitation  4
     // Item End Length        4
-    assert( NestedDataSet.GetLength<TDE>() % 2 == 0 );
+    xassert( NestedDataSet.GetLength<TDE>() % 2 == 0 );
     return TagField.GetLength() /* 4 */ + ValueLengthField.GetLength() /* 4 */
       + NestedDataSet.GetLength<TDE>() + 4 + 4;
     }
@@ -45,7 +45,7 @@ VL Item::GetLength() const
     // initially read explicit dataset in which case the two length cannot
     // related to each other
     //gdcmAssertAlwaysMacro( ValueLengthField == nestedlen );
-    assert( nestedlen % 2 == 0 );
+    xassert( nestedlen % 2 == 0 );
     return TagField.GetLength() /* 4 */ + ValueLengthField.GetLength() /* 4 */
       //+ ValueLengthField;
       + nestedlen;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmMediaStorage.cxx b/Source/DataStructureAndEncodingDefinition/gdcmMediaStorage.cxx
index 5a30639..c2f3ae5 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmMediaStorage.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmMediaStorage.cxx
@@ -164,13 +164,13 @@ MediaStorage::MSType MediaStorage::GetMSType(const char *str)
       }
     }
 
-  //assert(0);
+  //throw Exception("Structure error");
   return MS_END;
 }
 
 const char* MediaStorage::GetMSString(MSType ms)
 {
-  assert( ms <= MS_END );
+  xassert( ms <= MS_END );
   return MSStrings[(int)ms];
 }
 
@@ -323,21 +323,21 @@ static const MSModalityType MSModalityTypes[] = {
 unsigned int MediaStorage::GetNumberOfMSType()
 {
   const unsigned int n = MS_END;
-  assert( n > 0 );
+  xassert( n > 0 );
   return n;
 }
 
 unsigned int MediaStorage::GetNumberOfMSString()
 {
   static const unsigned int n = sizeof( MSStrings ) / sizeof( *MSStrings );
-  assert( n > 0 );
+  xassert( n > 0 );
   return n - 1;
 }
 
 unsigned int MediaStorage::GetNumberOfModality()
 {
   static const unsigned int n = sizeof( MSModalityTypes ) / sizeof( *MSModalityTypes );
-  assert( n > 0 );
+  xassert( n > 0 );
   return n - 1;
 }
 
@@ -345,7 +345,7 @@ const char *MediaStorage::GetModality() const
 {
   if (!MSModalityTypes[MSField].Modality)
     return NULL;
-  assert( MSModalityTypes[MSField].Modality[0] != ' ' ); // FIXME
+  xassert( MSModalityTypes[MSField].Modality[0] != ' ' ); // FIXME
   return MSModalityTypes[MSField].Modality;
 }
 
@@ -353,7 +353,7 @@ unsigned int MediaStorage::GetModalityDimension() const
 {
   if (!MSModalityTypes[MSField].Modality)
     return 0;
-  assert( MSModalityTypes[MSField].Dimension );
+  xassert( MSModalityTypes[MSField].Dimension );
   return MSModalityTypes[MSField].Dimension;
 }
 
@@ -461,7 +461,7 @@ void MediaStorage::SetFromSourceImageSequence(DataSet const &ds)
       const DataElement& de = subds.GetDataElement( referencedSOPClassUIDTag );
       const ByteValue *sopclassuid = de.GetByteValue();
       // LEADTOOLS_FLOWERS-8-PAL-Uncompressed.dcm
-      //assert( sopclassuid );
+      //xassert( sopclassuid );
       if( sopclassuid )
         {
         std::string sopclassuid_str(
@@ -474,7 +474,7 @@ void MediaStorage::SetFromSourceImageSequence(DataSet const &ds)
           sopclassuid_str = sopclassuid_str.substr(0,pos);
           }
         MediaStorage ms = MediaStorage::GetMSType(sopclassuid_str.c_str());
-        assert( ms != MS_END );
+        xassert( ms != MS_END );
         MSField = ms;
         }
       }
@@ -598,7 +598,7 @@ bool MediaStorage::SetFromFile(File const &file)
     ms2.SetFromSourceImageSequence(ds);
     if( MSField != ms2 && ms2 != MediaStorage::MS_END )
       {
-      assert( MediaStorage::IsImage( ms2 ) );
+      xassert( MediaStorage::IsImage( ms2 ) );
       gdcmWarningMacro( "Object is declared as SecondaryCaptureImageStorage but according"
         " to Source Image Sequence it was derived from " << ms2 << ". Using it instead" );
       MSField = ms2;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmPreamble.cxx b/Source/DataStructureAndEncodingDefinition/gdcmPreamble.cxx
index d69c3ac..06e1b1a 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmPreamble.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmPreamble.cxx
@@ -30,7 +30,7 @@ Preamble::~Preamble()
 std::istream &Preamble::Read(std::istream &is)
 {
   // \precondition: we are at beg of Preamble
-  assert ( !IsEmpty() /*&& is.tellg() == 0*/ );
+  xassert ( !IsEmpty() /*&& is.tellg() == 0*/ );
   if( is.read(Internal, 128+4) )
     {
     if( Internal[128+0] == 'D'
@@ -73,7 +73,7 @@ void Preamble::Remove()
 // \precondition we are at the beginning of file
 std::ostream const &Preamble::Write(std::ostream &os) const
 {
-//  assert ( os.tellg()+0 == 0 );
+//  xassert ( os.tellg()+0 == 0 );
   if( Internal )
     {
     os.write( Internal, 128+4);
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.cxx b/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.cxx
index 44917f6..8867c19 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.cxx
@@ -55,12 +55,12 @@ namespace gdcm_ns
       {
       const char *s1 = Owner.c_str();
       const char *s2 = _val.GetOwner();
-      assert( s1 );
-      assert( s2 );
+      xassert( s1 );
+      xassert( s2 );
       if( *s1 )
-        assert( s1[strlen(s1)-1] != ' ' );
+        xassert( s1[strlen(s1)-1] != ' ' );
       if( *s2 )
-        assert( s2[strlen(s2)-1] != ' ' );
+        xassert( s2[strlen(s2)-1] != ' ' );
       bool res = strcmp(s1, s2) < 0;
 #ifdef DEBUG_DUPLICATE
       if( *s1 && *s2 && gdcm::System::StrCaseCmp(s1,s2) == 0 && strcmp(s1,s2) != 0 )
@@ -68,11 +68,11 @@ namespace gdcm_ns
         // FIXME:
         // Typically this should only happen with the "Philips MR Imaging DD 001" vs "PHILIPS MR IMAGING DD 001"
         // or "Philips Imaging DD 001" vr "PHILIPS IMAGING DD 001"
-        //assert( strcmp(Owner.c_str(), _val.GetOwner()) == 0 );
+        //xassert( strcmp(Owner.c_str(), _val.GetOwner()) == 0 );
         //return true;
         const bool res2 = gdcm::System::StrCaseCmp(s1,s2) < 0;
         res = res2;
-        assert( 0 );
+        throw Exception("Structure error");
         }
 #endif
       return res;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.h b/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.h
index 6194373..3bc18ed 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmPrivateTag.h
@@ -66,7 +66,7 @@ private:
 
 inline std::ostream& operator<<(std::ostream &os, const PrivateTag &val)
 {
-  //assert( !val.Owner.empty() );
+  //xassert( !val.Owner.empty() );
   os.setf( std::ios::right );
   os << std::hex << '(' << std::setw( 4 ) << std::setfill( '0' )
     << val[0] << ',' << std::setw( 2 ) << std::setfill( '0' )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmReader.cxx b/Source/DataStructureAndEncodingDefinition/gdcmReader.cxx
index ed89771..04f387f 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmReader.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmReader.cxx
@@ -81,7 +81,7 @@ bool Reader::ReadDataSet()
 TransferSyntax Reader::GuessTransferSyntax()
 {
   // Don't call this function if you have a meta file info
-  //assert( Header->GetTransferSyntaxType() == TransferSyntax::TS_END );
+  //xassert( Header->GetTransferSyntaxType() == TransferSyntax::TS_END );
   std::streampos start = Stream->tellg();
   SwapCode sc = SwapCode::Unknown;
   TransferSyntax::NegociatedType nts = TransferSyntax::Unknown;
@@ -99,7 +99,7 @@ TransferSyntax Reader::GuessTransferSyntax()
       sc = SwapCode::BigEndian;
       break;
     default:
-      assert(0);
+      throw Exception("Structure error");
       }
     // Purposely not Re-use ReadVR since we can read VR_END
     char vr_str[3];
@@ -113,7 +113,7 @@ TransferSyntax Reader::GuessTransferSyntax()
       }
     else
       {
-      assert( !(VR::IsSwap(vr_str)));
+      xassert( !(VR::IsSwap(vr_str)));
       Stream->seekg(-2, std::ios::cur); // Seek back
       if( t.GetElement() == 0x0000 )
         {
@@ -136,7 +136,7 @@ TransferSyntax Reader::GuessTransferSyntax()
           gdcmWarningMacro( "Bad Big Endian" );
           break;
         default:
-          assert(0);
+          throw Exception("Structure error");
           }
         }
       nts = TransferSyntax::Implicit;
@@ -145,14 +145,14 @@ TransferSyntax Reader::GuessTransferSyntax()
   else
     {
     gdcmWarningMacro( "Start with a private tag creator" );
-    assert( t.GetGroup() > 0x0002 );
+    xassert( t.GetGroup() > 0x0002 );
     switch( t.GetElement() )
       {
     case 0x0010:
       sc = SwapCode::LittleEndian;
       break;
     default:
-      assert(0);
+      throw Exception("Structure error");
       }
     // Purposely not Re-use ReadVR since we can read VR_END
     char vr_str[3];
@@ -173,8 +173,8 @@ TransferSyntax Reader::GuessTransferSyntax()
       gdcmWarningMacro( "Very dangerous assertion needs some work" );
       }
     }
-  assert( nts != TransferSyntax::Unknown );
-  assert( sc != SwapCode::Unknown );
+  xassert( nts != TransferSyntax::Unknown );
+  xassert( sc != SwapCode::Unknown );
   if( nts == TransferSyntax::Implicit )
     {
     if( sc == SwapCode::BigEndian )
@@ -187,15 +187,15 @@ TransferSyntax Reader::GuessTransferSyntax()
       }
     else
       {
-      assert(0);
+      throw Exception("Structure error");
       }
     }
   else
     {
-    assert(0);
+    throw Exception("Structure error");
     }
   Stream->seekg( start, std::ios::beg );
-  assert( ts != TransferSyntax::TS_END );
+  xassert( ts != TransferSyntax::TS_END );
   return ts;
 }
 
@@ -223,7 +223,7 @@ namespace details
     static void Check(bool b, std::istream &stream)
       {
       (void)stream;
-      if( b ) assert( stream.eof() );
+      if( b ) xassert( stream.eof() );
       }
   };
 
@@ -358,7 +358,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
       }
     catch( ... )
       {
-      assert(0);
+      throw Exception("Structure error");
       }
 
     bool hasmetaheader = false;
@@ -370,7 +370,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
           {
           F->GetHeader().Read( is );
           hasmetaheader = true;
-          assert( !F->GetHeader().IsEmpty() );
+          xassert( !F->GetHeader().IsEmpty() );
           }
         catch( std::exception &ex )
           {
@@ -378,7 +378,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
           gdcmWarningMacro(ex.what());
           // Weird implicit meta header:
           is.seekg(128+4, std::ios::beg );
-          assert( is.good() );
+          xassert( is.good() );
           try
             {
             F->GetHeader().ReadCompat(is);
@@ -406,7 +406,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
     catch( ... )
       {
       // Ooops..
-      assert(0);
+      throw Exception("Structure error");
       }
     if( F->GetHeader().IsEmpty() )
       {
@@ -433,7 +433,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
 #endif
     zlib_stream::zip_istream gzis( is );
     // FIXME: we also know in this case that we are dealing with Explicit:
-    assert( ts.GetNegociatedType() == TransferSyntax::Explicit );
+    xassert( ts.GetNegociatedType() == TransferSyntax::Explicit );
     //F->GetDataSet().ReadUpToTag<ExplicitDataElement,SwapperNoOp>(gzis,tag, skiptags);
     caller.template ReadCommon<ExplicitDataElement,SwapperNoOp>(gzis);
     // I need the following hack to read: srwithgraphdeflated.dcm
@@ -477,14 +477,14 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
           std::streampos start = is.tellg();
           is.seekg( 0, std::ios::end);
           std::streampos end = is.tellg();
-          assert( !is.eof() );
-          assert( is.good() );
+          xassert( !is.eof() );
+          xassert( is.good() );
           std::streamoff theOffset = end-start;
-          assert (theOffset > 0 || (uint32_t)theOffset < std::numeric_limits<uint32_t>::max());
+          xassert (theOffset > 0 || (uint32_t)theOffset < std::numeric_limits<uint32_t>::max());
           VL l = (uint32_t)(theOffset);
           is.seekg( start, std::ios::beg );
-          assert( is.good() );
-          assert( !is.eof() );
+          xassert( is.good() );
+          xassert( !is.eof() );
           caller.template ReadCommonWithLength<ImplicitDataElement,SwapperNoOp>(is,l);
           }
         }
@@ -577,7 +577,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
       //
       gdcmWarningMacro( "Attempt to read Philips with ByteSwap private sequence wrongly encoded");
       F->GetDataSet().Clear(); // remove garbage from 1st attempt...
-      assert(0);  // TODO FIXME
+      throw Exception("Structure error");// TODO FIXME
       }
     else if( ex.GetLastElement().GetVR() == VR::INVALID )
       {
@@ -720,7 +720,7 @@ bool Reader::InternalReadCommon(const T_Caller &caller)
     success = false;
     }
 
-  //if( success ) assert( Stream->eof() );
+  //if( success ) xassert( Stream->eof() );
   caller.Check(success, *Stream );
     }
   catch( Exception &ex )
@@ -764,8 +764,8 @@ bool Reader::CanRead() const
 {
   // fastpath
   std::istream &is = *Stream;
-  assert( is.good() );
-  assert( is.tellg() == std::streampos(0) );
+  xassert( is.good() );
+  xassert( is.tellg() == std::streampos(0) );
     {
     is.seekg( 128, std::ios::beg ); // we ignore return value as we test is.good()
     char b[4];
@@ -809,14 +809,14 @@ bool Reader::CanRead() const
   if (bigendian)
     {
     t.Read<SwapperDoOp>(ss);
-    //assert( t.GetGroup() != 0x2 );
+    //xassert( t.GetGroup() != 0x2 );
     if( t.GetGroup() <= 0xff )
       sc = SwapCode::BigEndian;
     }
   else
     {
     t.Read<SwapperNoOp>(ss);
-    //assert( t.GetGroup() != 0x2 );
+    //xassert( t.GetGroup() != 0x2 );
     if( t.GetGroup() <= 0xff )
       sc = SwapCode::LittleEndian;
     }
@@ -898,7 +898,7 @@ bool Reader::CanRead() const
         }
       else
         {
-        assert( !(VR::IsSwap(vr_str)));
+        xassert( !(VR::IsSwap(vr_str)));
         is.seekg(-2, std::ios::cur); // Seek back
         gl.Read<SwapperNoOp>(is);
 
@@ -907,11 +907,11 @@ bool Reader::CanRead() const
           switch(gl)
             {
           case 0x00000004 :
-            assert( sc == SwapCode::LittleEndian);    // 1234
+            xassert( sc == SwapCode::LittleEndian);    // 1234
             sc = SwapCode::LittleEndian;    // 1234
             break;
           case 0x04000000 :
-            assert( sc == SwapCode::BigEndian);    // 1234
+            xassert( sc == SwapCode::BigEndian);    // 1234
             sc = SwapCode::BigEndian;       // 4321
             break;
           case 0x00040000 :
@@ -960,12 +960,12 @@ bool Reader::CanRead() const
         }
       else
         {
-        assert( !(VR::IsSwap(vr_str)));
+        xassert( !(VR::IsSwap(vr_str)));
         is.seekg(-2, std::ios::cur); // Seek back
         gl.Read<SwapperNoOp>(is);
         if( t.GetElement() == 0x0000 )
           {
-          assert( gl == 0x4 || gl == 0x04000000 );
+          xassert( gl == 0x4 || gl == 0x04000000 );
           }
         if( gl && gl < filelen )
           nts = TransferSyntax::Implicit;
@@ -984,7 +984,7 @@ bool Reader::CanRead() const
   if( nts == TransferSyntax::Explicit && sc == SwapCode::LittleEndian ) return true;
   if( nts == TransferSyntax::Explicit && sc == SwapCode::BigEndian ) return true;
 
-//  assert( nts == TransferSyntax::Unknown );
+//  xassert( nts == TransferSyntax::Unknown );
 //  if( sc != SwapCode::Unknown )
 //    {
 //    gdcm::Reader r;
@@ -1005,7 +1005,7 @@ void Reader::SetFileName(const char *filename)
   if( Ifstream->is_open() )
     {
     Stream = Ifstream;
-    assert( Stream && *Stream );
+    xassert( Stream && *Stream );
     }
   else
     {
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmReader.strict.cxx b/Source/DataStructureAndEncodingDefinition/gdcmReader.strict.cxx
index c6f6422..9c11fec 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmReader.strict.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmReader.strict.cxx
@@ -28,7 +28,7 @@ namespace gdcm
   bool StrictReadUpToTag( const char * filename, Tag const & last, std::set<Tag> const & skiptags )
     {
     gdcmstrict::Reader reader;
-    assert( filename );
+    xassert( filename );
     reader.SetFileName( filename );
     bool read = false;
     try
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.cxx b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.cxx
index 125b6be..e7776e3 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.cxx
@@ -27,7 +27,7 @@ void SequenceOfFragments::Clear()
 SequenceOfFragments::SizeType SequenceOfFragments::GetNumberOfFragments() const
 {
   // Do not count the last fragment
-  //assert( SequenceLengthField.IsUndefined() );
+  //xassert( SequenceLengthField.IsUndefined() );
   return Fragments.size();
 }
 
@@ -46,10 +46,10 @@ VL SequenceOfFragments::ComputeLength() const
   for(;it != Fragments.end(); ++it)
     {
     const VL fraglen = it->ComputeLength();
-    assert( fraglen % 2 == 0 );
+    xassert( fraglen % 2 == 0 );
     length += fraglen;
     }
-  assert( SequenceLengthField.IsUndefined() );
+  xassert( SequenceLengthField.IsUndefined() );
   length += 8; // seq end delimitor (tag + vl)
   return length;
 }
@@ -60,7 +60,7 @@ unsigned long SequenceOfFragments::ComputeByteLength() const
   FragmentVector::const_iterator it = Fragments.begin();
   for(;it != Fragments.end(); ++it)
     {
-    assert( !it->GetVL().IsUndefined() );
+    xassert( !it->GetVL().IsUndefined() );
     r += it->GetVL();
     }
   return r;
@@ -81,7 +81,7 @@ bool SequenceOfFragments::GetFragBuffer(unsigned int fragNb, char *buffer, unsig
 
 const Fragment& SequenceOfFragments::GetFragment(SizeType num) const
 {
-  assert( num < Fragments.size() );
+  xassert( num < Fragments.size() );
   FragmentVector::const_iterator it = Fragments.begin();
   const Fragment &frag = *(it+num);
   return frag;
@@ -103,8 +103,7 @@ bool SequenceOfFragments::GetBuffer(char *buffer, unsigned long length) const
   if( total != length )
     {
     //std::cerr << " DEBUG: " << total << " " << length << std::endl;
-    assert(0);
-    return false;
+    throw Exception("Structure error");
     }
   return true;
 }
@@ -117,7 +116,7 @@ bool SequenceOfFragments::WriteBuffer(std::ostream &os) const
     {
     const Fragment &frag = *it;
     const ByteValue *bv = frag.GetByteValue();
-    assert( bv );
+    xassert( bv );
     const VL len = frag.GetVL();
     bv->WriteBuffer(os);
     total += len;
@@ -125,7 +124,7 @@ bool SequenceOfFragments::WriteBuffer(std::ostream &os) const
   //if( total != length )
   //  {
   //  //std::cerr << " DEBUG: " << total << " " << length << std::endl;
-  //  assert(0);
+  //  throw Exception("Structure error");
   //  return false;
   //  }
   return true;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.h b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.h
index 4a50ea8..c2cae3d 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfFragments.h
@@ -85,7 +85,7 @@ public:
 template <typename TSwap>
 std::istream& Read(std::istream &is, bool readvalues = true)
 {
-  assert( SequenceLengthField.IsUndefined() );
+  xassert( SequenceLengthField.IsUndefined() );
   ReadPreValue<TSwap>(is);
   return ReadValue<TSwap>(is, readvalues);
 }
@@ -122,7 +122,7 @@ std::istream& ReadPreValue(std::istream &is)
     else
       {
       throw "Catch me if you can";
-      //assert(0);
+      //throw Exception("Structure error");
       }
     }
   return is;
@@ -141,7 +141,7 @@ std::istream& ReadValue(std::istream &is, bool /*readvalues*/)
       //gdcmDebugMacro( "Frag: " << frag );
       Fragments.push_back( frag );
       }
-    assert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
+    xassert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
     }
   catch(Exception &ex)
     {
@@ -161,9 +161,9 @@ std::istream& ReadValue(std::istream &is, bool /*readvalues*/)
     // 2. GENESIS_SIGNA-JPEG-CorruptFrag.dcm
     else if ( frag.GetTag() == Tag(0xddff,0x00e0) )
       {
-      assert( Fragments.size() == 1 );
+      xassert( Fragments.size() == 1 );
       const ByteValue *bv = Fragments[0].GetByteValue();
-      assert( (unsigned char)bv->GetPointer()[ bv->GetLength() - 1 ] == 0xfe );
+      xassert( (unsigned char)bv->GetPointer()[ bv->GetLength() - 1 ] == 0xfe );
       // Yes this is an extra copy, this is a bug anyway, go fix YOUR code
       Fragments[0].SetByteValue( bv->GetPointer(), bv->GetLength() - 1 );
       gdcmWarningMacro( "JPEG Fragment length was declared with an extra byte"
@@ -180,20 +180,20 @@ std::istream& ReadValue(std::istream &is, bool /*readvalues*/)
       // backward. This appears to be working on a set of DICOM/WSI files from
       // LEICA
       gdcmWarningMacro( "Trying to fix the even-but-odd value length bug #1" );
-      assert( Fragments.size() );
+      xassert( Fragments.size() );
       const size_t lastf = Fragments.size() - 1;
       const ByteValue *bv = Fragments[ lastf ].GetByteValue();
       const char *a = bv->GetPointer();
       gdcmAssertAlwaysMacro( (unsigned char)a[ bv->GetLength() - 1 ] == 0xfe );
       Fragments[ lastf ].SetByteValue( bv->GetPointer(), bv->GetLength() - 1 );
       is.seekg( -9, std::ios::cur );
-      assert( is.good() );
+      xassert( is.good() );
       while( frag.ReadBacktrack<TSwap>(is) && frag.GetTag() != seqDelItem )
         {
         gdcmDebugMacro( "Frag: " << frag );
         Fragments.push_back( frag );
         }
-      assert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
+      xassert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
       }
     // 4. LEICA/WSI (bis)
     else if ( frag.GetTag().GetGroup() == 0xe000 )
@@ -204,20 +204,20 @@ std::istream& ReadValue(std::istream &is, bool /*readvalues*/)
       // backward. This appears to be working on a set of DICOM/WSI files from
       // LEICA
       gdcmWarningMacro( "Trying to fix the even-but-odd value length bug #2" );
-      assert( Fragments.size() );
+      xassert( Fragments.size() );
       const size_t lastf = Fragments.size() - 1;
       const ByteValue *bv = Fragments[ lastf ].GetByteValue();
       const char *a = bv->GetPointer();
       gdcmAssertAlwaysMacro( (unsigned char)a[ bv->GetLength() - 2 ] == 0xfe );
       Fragments[ lastf ].SetByteValue( bv->GetPointer(), bv->GetLength() - 2 );
       is.seekg( -10, std::ios::cur );
-      assert( is.good() );
+      xassert( is.good() );
       while( frag.ReadBacktrack<TSwap>(is) && frag.GetTag() != seqDelItem )
         {
         gdcmDebugMacro( "Frag: " << frag );
         Fragments.push_back( frag );
         }
-      assert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
+      xassert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
       }
     // 5. LEICA/WSI (ter)
     else if ( (frag.GetTag().GetGroup() & 0x00ff) == 0x00e0
@@ -229,20 +229,20 @@ std::istream& ReadValue(std::istream &is, bool /*readvalues*/)
       // backward. This appears to be working on a set of DICOM/WSI files from
       // LEICA
       gdcmWarningMacro( "Trying to fix the even-but-odd value length bug #3" );
-      assert( Fragments.size() );
+      xassert( Fragments.size() );
       const size_t lastf = Fragments.size() - 1;
       const ByteValue *bv = Fragments[ lastf ].GetByteValue();
       const char *a = bv->GetPointer();
       gdcmAssertAlwaysMacro( (unsigned char)a[ bv->GetLength() - 3 ] == 0xfe );
       Fragments[ lastf ].SetByteValue( bv->GetPointer(), bv->GetLength() - 3 );
       is.seekg( -11, std::ios::cur );
-      assert( is.good() );
+      xassert( is.good() );
       while( frag.ReadBacktrack<TSwap>(is) && frag.GetTag() != seqDelItem )
         {
         gdcmDebugMacro( "Frag: " << frag );
         Fragments.push_back( frag );
         }
-      assert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
+      xassert( frag.GetTag() == seqDelItem && frag.GetVL() == 0 );
       }
     else
       {
@@ -263,8 +263,7 @@ std::ostream const &Write(std::ostream &os) const
 {
   if( !Table.Write<TSwap>(os) )
     {
-    assert(0 && "Should not happen");
-    return os;
+    throw Exception("Writing error");
     }
   for(ConstIterator it = Begin();it != End(); ++it)
     {
@@ -297,7 +296,7 @@ public:
       {
       os << "  " << *it << "\n";
       }
-    assert( SequenceLengthField.IsUndefined() );
+    xassert( SequenceLengthField.IsUndefined() );
       {
       const Tag seqDelItem(0xfffe,0xe0dd);
       VL zero = 0;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.cxx b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.cxx
index 8afebd9..89021cf 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.cxx
@@ -21,7 +21,7 @@ void SequenceOfItems::AddItem(Item const &item)
   Items.push_back( item );
   if( !SequenceLengthField.IsUndefined() )
     {
-    assert(0); // TODO
+    throw Exception("Structure error");// TODO
     }
 }
 
@@ -36,7 +36,7 @@ Item & SequenceOfItems::AddNewUndefinedLengthItem()
 void SequenceOfItems::Clear()
 {
   Items.clear();
-  assert( SequenceLengthField.IsUndefined() );
+  xassert( SequenceLengthField.IsUndefined() );
 }
 
 bool SequenceOfItems::RemoveItemByIndex( const SizeType position )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.h b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.h
index 9554ebf..c9e62c3 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.h
@@ -110,11 +110,11 @@ public:
       while( item.Read<TDE,TSwap>(is) && item.GetTag() != seqDelItem )
         {
         //gdcmDebugMacro( "Item: " << item );
-        assert( item.GetTag() != seqDelItem );
+        xassert( item.GetTag() != seqDelItem );
         Items.push_back( item );
         item.Clear();
         }
-      //assert( item.GetTag() == seqDelItem && item.GetVL() == 0 );
+      //xassert( item.GetTag() == seqDelItem && item.GetVL() == 0 );
       }
     else
       {
@@ -148,8 +148,8 @@ public:
         if( item.GetTag() == seqDelItem )
           {
           gdcmWarningMacro( "SegDelItem found in defined length Sequence. Skipping" );
-          assert( item.GetVL() == 0 );
-          assert( item.GetNestedDataSet().Size() == 0 );
+          xassert( item.GetVL() == 0 );
+          xassert( item.GetNestedDataSet().Size() == 0 );
           // we need to pay attention that the length of the Sequence of Items will be wrong
           // this way. Indeed by not adding this item we are changing the size of this sqi
           }
@@ -168,7 +168,7 @@ public:
           gdcmDebugMacro( "Found: Length of Item larger than expected" )
           throw "Length of Item larger than expected";
           }
-        assert( l <= SequenceLengthField );
+        xassert( l <= SequenceLengthField );
         //std::cerr << "sqi debug len: " << is.tellg() << " " <<  l << " " <<  SequenceLengthField << std::endl;
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
         // MR_Philips_Intera_No_PrivateSequenceImplicitVR.dcm
@@ -191,7 +191,7 @@ public:
           }
 #endif
         }
-      assert( l == SequenceLengthField );
+      xassert( l == SequenceLengthField );
       }
     return is;
     }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.txx b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.txx
index 8a0b2ef..b238d60 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmSequenceOfItems.txx
@@ -32,7 +32,7 @@ VL SequenceOfItems::ComputeLength() const
     }
   // For defined length SQ, make sure computation is correct (compare
   // to original length)
-  //assert( SequenceLengthField.IsUndefined()
+  //xassert( SequenceLengthField.IsUndefined()
   //  || length == SequenceLengthField );
   return length;
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmTag.h b/Source/DataStructureAndEncodingDefinition/gdcmTag.h
index 4104090..68b1c08 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmTag.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmTag.h
@@ -84,13 +84,13 @@ public:
   /// Returns the Group or Element of the given Tag, depending on id (0/1)
   const uint16_t &operator[](const unsigned int &_id) const
     {
-    assert(_id<2);
+    xassert(_id<2);
     return ElementTag.tags[_id];
     }
   /// Returns the Group or Element of the given Tag, depending on id (0/1)
   uint16_t &operator[](const unsigned int &_id)
     {
-    assert(_id<2);
+    xassert(_id<2);
     return ElementTag.tags[_id];
     }
 
@@ -194,7 +194,7 @@ public:
     {
     // See PS 3.5 - 7.8.1 PRIVATE DATA ELEMENT TAGS
     // eg: 0x0123,0x0045 -> 0x0123,0x4567
-    assert( t.IsPrivate() /*&& t.IsPrivateCreator()*/ );
+    xassert( t.IsPrivate() /*&& t.IsPrivateCreator()*/ );
     const uint16_t element = (uint16_t)(t.GetElement() << 8);
     const uint16_t base = (uint16_t)(GetElement() << 8);
     SetElement( (uint16_t)((base >> 8) + element) );
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmTransferSyntax.cxx b/Source/DataStructureAndEncodingDefinition/gdcmTransferSyntax.cxx
index c100136..5f9f005 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmTransferSyntax.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmTransferSyntax.cxx
@@ -113,14 +113,14 @@ TransferSyntax::TSType TransferSyntax::GetTSType(const char *cstr)
 
 const char* TransferSyntax::GetTSString(TSType ts)
 {
-  assert( ts <= TS_END );
+  xassert( ts <= TS_END );
   return TSStrings[(int)ts];
   //return TransferSyntaxStrings[(int)ts];
 }
 
 bool TransferSyntax::IsImplicit(TSType ts) const
 {
-  assert( ts != TS_END );
+  xassert( ts != TS_END );
   return ts == ImplicitVRLittleEndian
     || ts == ImplicitVRBigEndianACRNEMA
     || ts == ImplicitVRBigEndianPrivateGE
@@ -223,7 +223,7 @@ bool TransferSyntax::IsLossless() const
 // By implementation those two functions form a partition
 bool TransferSyntax::IsExplicit(TSType ts) const
 {
-  assert( ts != TS_END );
+  xassert( ts != TS_END );
   return !IsImplicit(ts);
 }
 
@@ -242,13 +242,13 @@ TransferSyntax::NegociatedType TransferSyntax::GetNegociatedType() const
 
 bool TransferSyntax::IsLittleEndian(TSType ts) const
 {
-  assert( ts != TS_END );
+  xassert( ts != TS_END );
   return !IsBigEndian(ts);
 }
 
 bool TransferSyntax::IsBigEndian(TSType ts) const
 {
-  assert( ts != TS_END );
+  xassert( ts != TS_END );
   return ts == ExplicitVRBigEndian
 //    || ts == ImplicitVRBigEndianPrivateGE // Indeed this is LittleEndian
     || ts == ImplicitVRBigEndianACRNEMA;
@@ -256,12 +256,12 @@ bool TransferSyntax::IsBigEndian(TSType ts) const
 
 SwapCode TransferSyntax::GetSwapCode() const
 {
-  assert( TSField != TS_END );
+  xassert( TSField != TS_END );
   if( IsBigEndian( TSField ) )
     {
     return SwapCode::BigEndian;
     }
-  assert( IsLittleEndian( TSField ) );
+  xassert( IsLittleEndian( TSField ) );
   return SwapCode::LittleEndian;
 }
 
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.cxx
index 9e8519e..ad56fba 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL UNExplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -37,18 +37,17 @@ VL UNExplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & (VR::OB | VR::OW) );
+      xassert( VRField & (VR::OB | VR::OW) );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
-    assert(0);
-  return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + 2*VRField.GetLength() + ValueLengthField;
     }
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.txx
index 7d1a962..0b482a0 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitDataElement.txx
@@ -44,7 +44,7 @@ std::istream &UNExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !is.eof() ) // FIXME This should not be needed
       {
-      assert(0 && "Should not happen" );
+      throw Exception("Truncated file");
       }
     return is;
     }
@@ -54,15 +54,14 @@ std::istream &UNExplicitDataElement::ReadPreValue(std::istream &is)
     pe.SetLastElement( *this );
     throw pe;
     }
-  assert( TagField != Tag(0xfffe,0xe0dd) );
+  xassert( TagField != Tag(0xfffe,0xe0dd) );
 
   const Tag itemDelItem(0xfffe,0xe00d);
   if( TagField == itemDelItem )
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( ValueLengthField != 0 )
       {
@@ -80,21 +79,20 @@ std::istream &UNExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !VRField.Read(is) )
       {
-      assert(0 && "Should not happen" );
-      return is;
+      throw Exception("Truncated file");
       }
     }
   catch( Exception &ex )
     {
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
     // gdcm-MR-PHILIPS-16-Multi-Seq.dcm
-    // assert( TagField == Tag(0xfffe, 0xe000) );
+    // xassert( TagField == Tag(0xfffe, 0xe000) );
     // -> For some reason VR is written as {44,0} well I guess this is a VR...
     // Technically there is a second bug, dcmtk assume other things when reading this tag,
     // so I need to change this tag too, if I ever want dcmtk to read this file. oh well
     // 0019004_Baseline_IMG1.dcm
     // -> VR is garbage also...
-    // assert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
+    // xassert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
     //gdcmWarningMacro( "Assuming 16 bits VR for Tag=" <<
     //  TagField << " in order to read a buggy DICOM file." );
     //VRField = VR::INVALID;
@@ -117,8 +115,7 @@ std::istream &UNExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     }
   else
@@ -126,8 +123,7 @@ std::istream &UNExplicitDataElement::ReadPreValue(std::istream &is)
     // 16bits only
     if( !ValueLengthField.template Read16<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     }
   return is;
@@ -146,11 +142,11 @@ std::istream &UNExplicitDataElement::ReadValue(std::istream &is, bool readvalues
 
   //std::cerr << "exp cur tag=" << TagField << " VR=" << VRField << " VL=" << ValueLengthField << std::endl;
   // Read the Value
-  //assert( ValueField == 0 );
+  //xassert( ValueField == 0 );
   if( VRField == VR::SQ )
     {
     // Check whether or not this is an undefined length sequence
-    assert( TagField != Tag(0x7fe0,0x0010) );
+    xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new SequenceOfItems;
     }
   else if( ValueLengthField.IsUndefined() )
@@ -161,7 +157,7 @@ std::istream &UNExplicitDataElement::ReadValue(std::istream &is, bool readvalues
       // Enhanced_MR_Image_Storage_PixelSpacingNotIn_0028_0030.dcm (illegal)
       // vs
       // undefined_length_un_vr.dcm
-      assert( TagField != Tag(0x7fe0,0x0010) );
+      xassert( TagField != Tag(0x7fe0,0x0010) );
       ValueField = new SequenceOfItems;
       ValueField->SetLength(ValueLengthField); // perform realloc
       try
@@ -169,7 +165,7 @@ std::istream &UNExplicitDataElement::ReadValue(std::istream &is, bool readvalues
         //if( !ValueIO<UNExplicitDataElement,TSwap>::Read(is,*ValueField) ) // non cp246
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) ) // cp246 compliant
           {
-          assert(0);
+          throw Exception("Truncated file");
           }
         }
       catch( std::exception &)
@@ -184,14 +180,14 @@ std::istream &UNExplicitDataElement::ReadValue(std::istream &is, bool readvalues
     else
       {
       // Ok this is Pixel Data fragmented...
-      assert( TagField == Tag(0x7fe0,0x0010) );
-      assert( VRField & VR::OB_OW );
+      xassert( TagField == Tag(0x7fe0,0x0010) );
+      xassert( VRField & VR::OB_OW );
       ValueField = new SequenceOfFragments;
       }
     }
   else
     {
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new ByteValue;
     }
   // We have the length we should be able to read the value
@@ -209,7 +205,7 @@ std::istream &UNExplicitDataElement::ReadValue(std::istream &is, bool readvalues
     //we really need to read item marker
   )
     {
-    assert(0); // Could we possibly be so unlucky to have this mixture of bugs...
+    throw Exception("Structure error");// Could we possibly be so unlucky to have this mixture of bugs...
     }
 
   if( !ValueIO<UNExplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) )
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.cxx
index 43d5c2d..a96d5fd 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL UNExplicitImplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -37,18 +37,17 @@ VL UNExplicitImplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & (VR::OB | VR::OW) );
+      xassert( VRField & (VR::OB | VR::OW) );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
-    assert(0);
-  return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + 2*VRField.GetLength() + ValueLengthField;
     }
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.txx
index e1bc51e..cb0dc3a 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmUNExplicitImplicitDataElement.txx
@@ -37,7 +37,7 @@ std::istream &UNExplicitImplicitDataElement::Read(std::istream &is)
 template <typename TSwap>
 std::istream &UNExplicitImplicitDataElement::ReadPreValue(std::istream &is)
 {
-  assert(0);
+  throw Exception("Structure error");
   //DataElement &de = *this;//unused de, fires a warning on macos
   //de.template ReadPreValue<UNExplicitDataElement,TSwap>( is );
   return is;
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVL.h b/Source/DataStructureAndEncodingDefinition/gdcmVL.h
index c4d5ec5..75efeea 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVL.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVL.h
@@ -91,7 +91,7 @@ public:
     is.read((char*)(&copy), sizeof(uint16_t));
     TSwap::SwapArray(&copy,1);
     ValueLength = copy;
-    assert( ValueLength <=  65535 /*UINT16_MAX*/ ); // ?? doh !
+    xassert( ValueLength <=  65535 /*UINT16_MAX*/ ); // ?? doh !
     return is;
     }
 
@@ -110,7 +110,7 @@ public:
   template <typename TSwap>
   const std::ostream &Write16(std::ostream &os) const
     {
-    assert( ValueLength <=   65535 /*UINT16_MAX*/ );
+    xassert( ValueLength <=   65535 /*UINT16_MAX*/ );
     uint16_t copy = (uint16_t)ValueLength;
     if( IsOdd() )
       {
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVM.cxx b/Source/DataStructureAndEncodingDefinition/gdcmVM.cxx
index d46bbfd..bb41530 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVM.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVM.cxx
@@ -138,15 +138,15 @@ unsigned int VM::GetLength() const
     return 0;
   default:
     len = 0;
-    assert(0);
+    throw Exception("Structure error");
     }
-  assert( len );
+  xassert( len );
   return len;
 }
 
 unsigned int VM::GetIndex(VMType vm)
 {
-  assert( vm <= VM_END );
+  xassert( vm <= VM_END );
   unsigned int l;
   switch(vm)
     {
@@ -224,8 +224,8 @@ unsigned int VM::GetIndex(VMType vm)
 const char *VM::GetVMString(VMType vm)
 {
   unsigned int idx = GetIndex(vm);
-  assert( idx < sizeof(VMStrings) / sizeof(VMStrings[0]) );
-  //assert( idx );
+  xassert( idx < sizeof(VMStrings) / sizeof(VMStrings[0]) );
+  //xassert( idx );
   return VMStrings[idx];
 }
 
@@ -249,7 +249,7 @@ VM::VMType VM::GetVMType(const char *vm)
 bool VM::IsValid(int vm1, VMType vm2)
 {
   bool r = false;
-  assert( vm1 >= 0 ); // Still need to check Part 3
+  xassert( vm1 >= 0 ); // Still need to check Part 3
   // If you update the VMType, you need to update this code. Hopefully a compiler is
   // able to tell when a case is missing
   switch(vm2)
@@ -312,7 +312,7 @@ bool VM::IsValid(int vm1, VMType vm2)
     r = (vm1 >= 3);
     break;
   default:
-    assert(0); // should not happen
+    throw Exception("Structure error");// should not happen
     }
   return r;
 }
@@ -381,7 +381,7 @@ unsigned int VM::GetNumberOfElementsFromArray(const char *array, unsigned int le
 bool VM::Compatible(VM const &vm) const
 {
   // make sure that vm is a numeric value
-  //assert( vm.VMField <= VM256 );
+  //xassert( vm.VMField <= VM256 );
   if ( VMField == VM::VM0 ) return false; // nothing was found in the dict
   if ( vm == VM::VM0 ) return true; // the user was not able to compute the vm from the empty bytevalue
   // let's start with the easy case:
@@ -430,7 +430,7 @@ bool VM::Compatible(VM const &vm) const
     }
   if( r )
     {
-    assert( VMField & vm.VMField );
+    xassert( VMField & vm.VMField );
     }
   return r;
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVM.h b/Source/DataStructureAndEncodingDefinition/gdcmVM.h
index b63531a..9868202 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVM.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVM.h
@@ -142,7 +142,7 @@ private:
 //-----------------------------------------------------------------------------
 inline std::ostream& operator<<(std::ostream& _os, const VM &_val)
 {
-  assert( VM::GetVMString(_val) );
+  xassert( VM::GetVMString(_val) );
   _os << VM::GetVMString(_val);
   return _os;
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVR.cxx b/Source/DataStructureAndEncodingDefinition/gdcmVR.cxx
index 824801e..8033f9a 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVR.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVR.cxx
@@ -217,7 +217,7 @@ unsigned int VR::GetSizeof() const
   default:
     size = 0;
     }
-  assert( size );
+  xassert( size );
   return size;
 }
 
@@ -225,7 +225,7 @@ int VR::GetIndex(VRType vr)
 {
   if( vr == VR::VL32 ) return 0;
   int l;
-  assert( vr <= VR_END );
+  xassert( vr <= VR_END );
   switch(vr)
     {
   case INVALID:
@@ -264,13 +264,13 @@ const char *VR::GetVRStringFromFile(VRType vr)
 {
 #if 1
   static const int N = sizeof(VRValue) / sizeof(VRType);
-  assert( N == 28 );
+  xassert( N == 28 );
   static VRType *start = VRValue;
   static VRType *end   = VRValue+N;
   const VRType *p =
     std::lower_bound(start, end, vr);
-  assert( *p == vr );
-  assert( (p - start) == GetIndex(vr) );
+  xassert( *p == vr );
+  xassert( (p - start) == GetIndex(vr) );
   return VRStrings[p-start];
 #else
   int idx = GetIndex(vr);
@@ -299,7 +299,7 @@ VR::VRType VR::GetVRTypeFromFile(const char *vr)
  */
 #if 1
   static const int N = sizeof(VRValue) / sizeof(VRType);
-  assert( N == 28 );
+  xassert( N == 28 );
   static const char **start = VRStrings+1;
   static const char **end   = VRStrings+N;
   //std::cerr << "VR=" << vr << std::endl;
@@ -318,9 +318,9 @@ VR::VRType VR::GetVRTypeFromFile(const char *vr)
       }
     return VR::INVALID;
     }
-  assert( (*p)[0] == vr[0] && (*p)[1] == vr[1] );
+  xassert( (*p)[0] == vr[0] && (*p)[1] == vr[1] );
   VRType r = VRValue[p-start+1];
-  assert( r == (VR::VRType)(1 << (p-start)) );
+  xassert( r == (VR::VRType)(1 << (p-start)) );
 #else // old version not optimized
   VRType r = VR::VR_END;
   for (int i = 1; VRStrings[i] != NULL; i++)
@@ -335,7 +335,7 @@ VR::VRType VR::GetVRTypeFromFile(const char *vr)
     }
 #endif
   // postcondition
-  assert( r != VR::INVALID
+  xassert( r != VR::INVALID
        && r != VR::OB_OW
        && r != VR::US_SS
        && r != VR::US_SS_OW
@@ -366,10 +366,10 @@ VR::VRType VR::GetVRType(const char *vr)
         r = US_SS_OW;
         break;
       case 31:
-        r = VR_END; assert(0);
+        r = VR_END; throw Exception("Structure error");
         break;
       default:
-        assert( vr[2] == 0 );
+        xassert( vr[2] == 0 );
         r = (VR::VRType)(1 << (i-1));
         }
       break; // found one value, we can exit the for loop
@@ -386,7 +386,7 @@ bool VR::IsValid(const char *vr)
     // Use lazy evaluation instead of strncmp
     if (ref[0] == vr[0] && ref[1] == vr[1] )
       {
-      assert( i < 28 ); // FIXME
+      xassert( i < 28 ); // FIXME
       return true;
       }
     }
@@ -395,19 +395,19 @@ bool VR::IsValid(const char *vr)
 
 bool VR::IsValid(const char *vr1, VRType vr2)
 {
-  assert( strlen(vr1) == 2 );
+  xassert( strlen(vr1) == 2 );
   VR::VRType vr = GetVRType(vr1);
   return ((vr & vr2) != 0 ? true : false);
 }
 
 bool VR::IsSwap(const char *vr)
 {
-  assert( vr[2] == '\0' );
+  xassert( vr[2] == '\0' );
   char vr_swap[3];
   vr_swap[0] = vr[1];
   vr_swap[1] = vr[0];
   vr_swap[2] = '\0';
-  assert( GetVRType(vr_swap) != SS );
+  xassert( GetVRType(vr_swap) != SS );
   return GetVRType(vr_swap) != VR_END;
 }
 
@@ -446,20 +446,20 @@ VRTemplateCase(UT,rep)
 
 bool VR::IsASCII(VRType vr)
 {
-  //assert( vr != VR::INVALID );
+  //xassert( vr != VR::INVALID );
   switch(vr)
     {
     VRTemplate(VRASCII)
   default:
       // 1.3.12.2.1107.5.1.4.54035.30000005100516290423400005768-no-phi.dcm has a VR=RT
-      //assert(0);
-      return false;
+      //throw Exception("Structure error");
+    return false;
     }
 }
 
 bool VR::IsASCII2(VRType vr)
 {
-  assert( vr != VR::INVALID );
+  xassert( vr != VR::INVALID );
   return
     vr == AE ||
     vr == AS ||
@@ -479,7 +479,7 @@ bool VR::IsASCII2(VRType vr)
 
 bool VR::IsBinary(VRType vr)
 {
-  //assert( vr != VR::INVALID );
+  //xassert( vr != VR::INVALID );
   switch(vr)
     {
     VRTemplate(VRBINARY)
@@ -492,14 +492,14 @@ bool VR::IsBinary(VRType vr)
     return true;
   default:
       // 1.3.12.2.1107.5.1.4.54035.30000005100516290423400005768-no-phi.dcm has a VR=RT
-      //assert(0);
-      return false;
+      //throw Exception("Structure error");
+    return false;
     }
 }
 
 bool VR::IsBinary2(VRType vr)
 {
-  //assert( vr != OF );
+  //xassert( vr != OF );
   return
     vr == OB ||
     vr == OW ||
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVR.h b/Source/DataStructureAndEncodingDefinition/gdcmVR.h
index fddb94e..00b4ee6 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVR.h
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVR.h
@@ -151,7 +151,7 @@ public:
     char vr[2];
     is.read(vr, 2);
     VRField = GetVRTypeFromFile(vr);
-    assert( VRField != VR::VR_END );
+    xassert( VRField != VR::VR_END );
     if( VRField == VR::INVALID )
     {
       // \0\2 Data/TheralysGDCM120Bug.dcm
@@ -192,8 +192,8 @@ public:
       //vrfield = VR::UN;
       }
     const char *vr = GetVRString(vrfield);
-    //assert( strlen( vr ) == 2 );
-    assert( vr[0] && vr[1] && vr[2] == 0 );
+    //xassert( strlen( vr ) == 2 );
+    xassert( vr[0] && vr[1] && vr[2] == 0 );
     os.write(vr, 2);
     // See PS 3.5, Data Element Structure With Explicit VR
     if( vrfield & VL32 )
@@ -334,7 +334,7 @@ inline unsigned int VR::GetSize() const
     case VR::US_SS:
       return 2;
     default:
-       assert( 0 && "should not" );
+       throw Exception("Structure error");
   }
   return 0;
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.cxx b/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.cxx
index f25f43e..2ce0e74 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.cxx
@@ -24,7 +24,7 @@ VL VR16ExplicitDataElement::GetLength() const
 {
   if( ValueLengthField.IsUndefined() )
     {
-    assert( ValueField->GetLength().IsUndefined() );
+    xassert( ValueField->GetLength().IsUndefined() );
     Value *p = ValueField;
     // If this is a SQ we need to compute it's proper length
     SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(p);
@@ -37,18 +37,17 @@ VL VR16ExplicitDataElement::GetLength() const
     SequenceOfFragments *sf = dynamic_cast<SequenceOfFragments*>(p);
     if( sf )
       {
-      assert( VRField & (VR::OB | VR::OW) );
+      xassert( VRField & (VR::OB | VR::OW) );
       return TagField.GetLength() + VRField.GetLength()
         + ValueLengthField.GetLength() + sf->ComputeLength();
       }
-    assert(0);
-  return 0;
+    throw Exception("Structure error");
     }
   else
     {
     // Each time VR::GetLength() is 2 then Value Length is coded in 2
     //                              4 then Value Length is coded in 4
-    assert( !ValueField || ValueField->GetLength() == ValueLengthField );
+    xassert( !ValueField || ValueField->GetLength() == ValueLengthField );
     return TagField.GetLength() + 2*VRField.GetLength() + ValueLengthField;
     }
 }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.txx b/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.txx
index 57fa386..b7b4871 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmVR16ExplicitDataElement.txx
@@ -43,21 +43,20 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !is.eof() ) // FIXME This should not be needed
       {
-      assert(0 && "Should not happen" );
+      throw Exception("Truncated file");
       }
     return is;
     }
-  assert( TagField != Tag(0xfffe,0xe0dd) );
-  //assert( TagField != Tag(0xfeff,0xdde0) );
+  xassert( TagField != Tag(0xfffe,0xe0dd) );
+  //xassert( TagField != Tag(0xfeff,0xdde0) );
   const Tag itemDelItem(0xfffe,0xe00d);
   const Tag itemStartItem(0xfffe,0x0000);
-  assert( TagField != itemStartItem );
+  xassert( TagField != itemStartItem );
   if( TagField == itemDelItem )
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( ValueLengthField )
       {
@@ -72,7 +71,7 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
   if( TagField == Tag(0x00ff, 0x4aa5) )
     {
-    assert(0 && "Should not happen" );
+    throw Exception("Structure error");
     //  char c;
     //  is.read(&c, 1);
     //  std::cerr << "Debug: " << c << std::endl;
@@ -87,8 +86,7 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !VRField.Read(is) )
       {
-      assert(0 && "Should not happen" );
-      return is;
+      throw Exception("Truncated file");
       }
     }
   catch( Exception & )
@@ -107,14 +105,14 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
     // so I need to change this tag too, if I ever want dcmtk to read this file. oh well
     // 0019004_Baseline_IMG1.dcm
     // -> VR is garbage also...
-    // assert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
+    // xassert( TagField == Tag(8348,0339) || TagField == Tag(b5e8,0338))
     if( TagField == Tag(0x7fe0,0x0010) )
       {
       OX_hack = true;
       VRField = VR::UN; // make it a fake 32bits for now...
       char dummy[2];
       is.read(dummy,2);
-      assert( dummy[0] == 0 && dummy[1] == 0 );
+      xassert( dummy[0] == 0 && dummy[1] == 0 );
       gdcmWarningMacro( "Assuming 32 bits VR for Tag=" <<
         TagField << " in order to read a buggy DICOM file." );
       }
@@ -129,8 +127,7 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
     {
     if( !ValueLengthField.Read<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
     if( OX_hack )
       {
@@ -139,12 +136,11 @@ std::istream &VR16ExplicitDataElement::ReadPreValue(std::istream &is)
     }
   else
     {
-    assert( OX_hack == false );
+    xassert( OX_hack == false );
     // 16bits only
     if( !ValueLengthField.template Read16<TSwap>(is) )
       {
-      assert(0 && "Should not happen");
-      return is;
+      throw Exception("Truncated file");
       }
 #ifdef GDCM_SUPPORT_BROKEN_IMPLEMENTATION
     // HACK for SIEMENS Leonardo
@@ -185,11 +181,11 @@ std::istream &VR16ExplicitDataElement::ReadValue(std::istream &is, bool readvalu
     }
 
   // Read the Value
-  //assert( ValueField == 0 );
+  //xassert( ValueField == 0 );
   if( VRField == VR::SQ )
     {
     // Check whether or not this is an undefined length sequence
-    assert( TagField != Tag(0x7fe0,0x0010) );
+    xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new SequenceOfItems;
     }
   else if( ValueLengthField.IsUndefined() )
@@ -200,7 +196,7 @@ std::istream &VR16ExplicitDataElement::ReadValue(std::istream &is, bool readvalu
       // Enhanced_MR_Image_Storage_PixelSpacingNotIn_0028_0030.dcm (illegal)
       // vs
       // undefined_length_un_vr.dcm
-      assert( TagField != Tag(0x7fe0,0x0010) );
+      xassert( TagField != Tag(0x7fe0,0x0010) );
       ValueField = new SequenceOfItems;
       ValueField->SetLength(ValueLengthField); // perform realloc
       try
@@ -208,7 +204,7 @@ std::istream &VR16ExplicitDataElement::ReadValue(std::istream &is, bool readvalu
         //if( !ValueIO<VR16ExplicitDataElement,TSwap>::Read(is,*ValueField) ) // non cp246
         if( !ValueIO<ImplicitDataElement,TSwap>::Read(is,*ValueField,readvalues) ) // cp246 compliant
           {
-          assert(0);
+          throw Exception("Truncated file");
           }
         }
       catch( std::exception &)
@@ -232,14 +228,14 @@ std::istream &VR16ExplicitDataElement::ReadValue(std::istream &is, bool readvalu
         throw pe;
         }
       // Ok this is Pixel Data fragmented...
-      assert( TagField == Tag(0x7fe0,0x0010) );
-      assert( VRField & VR::OB_OW );
+      xassert( TagField == Tag(0x7fe0,0x0010) );
+      xassert( VRField & VR::OB_OW );
       ValueField = new SequenceOfFragments;
       }
     }
   else
     {
-    //assert( TagField != Tag(0x7fe0,0x0010) );
+    //xassert( TagField != Tag(0x7fe0,0x0010) );
     ValueField = new ByteValue;
     }
   // We have the length we should be able to read the value
@@ -258,17 +254,17 @@ std::istream &VR16ExplicitDataElement::ReadValue(std::istream &is, bool readvalu
   )
     {
     gdcmWarningMacro( "ByteSwaping Private SQ: " << TagField );
-    assert( VRField == VR::SQ );
-    assert( TagField.IsPrivate() );
+    xassert( VRField == VR::SQ );
+    xassert( TagField.IsPrivate() );
     try
       {
       if( !ValueIO<VR16ExplicitDataElement,SwapperDoOp>::Read(is,*ValueField,readvalues) )
         {
-        assert(0 && "Should not happen");
+        throw Exception("Truncated file");
         }
       Value* v = &*ValueField;
       SequenceOfItems *sq = dynamic_cast<SequenceOfItems*>(v);
-      assert( sq );
+      xassert( sq );
       SequenceOfItems::Iterator it = sq->Begin();
       for( ; it != sq->End(); ++it)
         {
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmValueIO.txx b/Source/DataStructureAndEncodingDefinition/gdcmValueIO.txx
index d5d2685..a9ff144 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmValueIO.txx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmValueIO.txx
@@ -42,7 +42,7 @@ namespace gdcm_ns
       }
     else
       {
-      assert( 0 && "error" );
+      throw Exception("Structure error");
       }
     return is;
   }
@@ -57,7 +57,7 @@ namespace gdcm_ns
     else if( const SequenceOfItems *si = dynamic_cast<const SequenceOfItems*>(v) )
       {
       //VL dummy = si->ComputeLength<DE>();
-      //assert( /*dummy.IsUndefined() ||*/ dummy == si->GetLength() );
+      //xassert( /*dummy.IsUndefined() ||*/ dummy == si->GetLength() );
       si->template Write<DE,TSwap>(os);
       }
     else if( const SequenceOfFragments *sf = dynamic_cast<const SequenceOfFragments*>(v) )
@@ -66,7 +66,7 @@ namespace gdcm_ns
       }
     else
       {
-      assert( 0 && "error" );
+      throw Exception("Structure error");
       }
     return os;
   }
diff --git a/Source/DataStructureAndEncodingDefinition/gdcmWriter.cxx b/Source/DataStructureAndEncodingDefinition/gdcmWriter.cxx
index 144e907..cb6fbc4 100644
--- a/Source/DataStructureAndEncodingDefinition/gdcmWriter.cxx
+++ b/Source/DataStructureAndEncodingDefinition/gdcmWriter.cxx
@@ -101,7 +101,7 @@ bool Writer::Write()
     //gzostream gzos(os.rdbuf());
       try {
       zlib_stream::zip_ostream gzos( os );
-      assert( ts.GetNegociatedType() == TransferSyntax::Explicit );
+      xassert( ts.GetNegociatedType() == TransferSyntax::Explicit );
       DS.Write<ExplicitDataElement,SwapperNoOp>(gzos);
       //gzos.flush();
       } catch (...){
@@ -124,7 +124,7 @@ bool Writer::Write()
         }
       else
         {
-        assert( ts.GetNegociatedType() == TransferSyntax::Explicit );
+        xassert( ts.GetNegociatedType() == TransferSyntax::Explicit );
         DS.Write<ExplicitDataElement,SwapperDoOp>(os);
         }
       }
@@ -136,7 +136,7 @@ bool Writer::Write()
         }
       else
         {
-        assert( ts.GetNegociatedType() == TransferSyntax::Explicit );
+        xassert( ts.GetNegociatedType() == TransferSyntax::Explicit );
         DS.Write<ExplicitDataElement,SwapperNoOp>(os);
         }
       }
@@ -173,8 +173,8 @@ void Writer::SetFileName(const char *filename)
       }
     Ofstream = new std::ofstream();
     Ofstream->open(filename, std::ios::out | std::ios::binary );
-    assert( Ofstream->is_open() );
-    assert( !Ofstream->fail() );
+    xassert( Ofstream->is_open() );
+    xassert( !Ofstream->fail() );
     //std::cerr << Stream.is_open() << std::endl;
     Stream = Ofstream;
   }
