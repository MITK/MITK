/**
\page PropertiesPage Properties

\section PropertyConcept The Concept Behind MITK Properties

Properties belong to a datanode and contain information relevant to the handling of the node by MITK. They provide a place to store additional information which is not part of the actual data, and as such have no reason to be contained within the data/file itself, but might be needed for such things as rendering (e.g. transfer functions) or interaction (e.g. the name of the node).

Propteries can be read and set:

\code
//1: Read a property
mitk::Property::Pointer readProperty = node->GetProperty("color"); //read the property "color" from the data node
mitk::ColorProperty::Pointer colorProperty = dynamic_cast<mitk::ColorProperty*>(readProperty); //cast this property to the subtype ColorProperty

//2: Write a property
mitk::BoolProperty::Pointer newProperty = mitk::BoolProperty::New( true ); //create a new property, in this case a boolean property
node->SetProperty( "IsTensorVolume", newProperty ); //add this property to node with the key "IsTensorVolume"
\endcode

\section ListOfIndependentProperty A List Of Module Independent Properties

This section lists most of the known properties in MITK according to where they are used. Not every node needs each 
(or even close to) of these properties.

\subsection FileManagement File Management
<ul>
  <li> path - The physical path the file was loaded from
  <li> name - The node name in the datamanager
  <li> selected - Whether the node is selected in the datamanager
</ul>

\subsection GenericRenderingProperty Generic Rendering Properties
<ul>
  <li> color - Color the surface, grey value image, whatever should be rendered in (default is usually white). There is a special mitk::ColorProperty and you can use the Getter/Setter methods to access it. The color is defined with three values (RGB) in the range between 0.0 and 1.0. 
\remark If you are inside a mapper you can use the following code to access 
the color:
\code
float rgb[3]={1.0f, 1.0f, 1.0f};
GetColor( rgb, BaseRenderer );
\endcode
(The BaseRenderer is usually known inside a mapper).

\warning
This property will not affect images if you set the property "use color" 
to false. In that case a user-defined lookuptable will be used.

  <li> in plane resample extent by geometry - Toggles:
Resampling grid corresponds to the current world geometry. This
means that the spacing of the output 2D image depends on the
currently selected world geometry, and *not* on the image itself.
  <li> Resampling grid corresponds to the input geometry. This means that
the spacing of the output 2D image is directly derived from the
associated input image, regardless of the currently selected world
geometry.
  <li> layer - Controls which image is considered "on top" of another. In the case 
that two should inhabit the same space, the higher layer occludes lower layer.
So far it works for images and pointsets. The layer property applies only for similar datatypes. Pointsets are always rendered in front of images and the layer will not have any effect.
  <li> levelwindow - In general, grayscale images contain values between 0 and 255. Therefore, the default window boundaries are set respectively. For displaying the image within a certain range, ie. 50 - 200, this property can be used to adjust the minimum and maximum boundary.
  <li> LookupTable - This property contains a user defined lookuptable, which can be used to map scalar values to color values. Example: If an image contains a value of 128, in the resulting image the passed lookuptable could map this value to red (255, 0, 0).

  \warning
This property will not effect images if you set the property "use color" 
to true. In that case color properties and a default lookuptable are used.

Example for setting up a lookuptable in MITK:
\code
#include <vtkSmartPointer.h>
#include <vtkLookupTable.h>
#include <mitkLookupTable.h>
#include <mitkLookupTableProperty.h>

[...]

vtkSmartPointer<vtkLookupTable> vtkLUT = vtkSmartPointer<vtkLookupTable>::New();
vtkLUT->SetRange(100,200); //define your table here
vtkLUT->Build();

//pass the table to MITK
mitk::LookupTable::Pointer mitkLookupTable = mitk::LookupTable::New();
mitkLookupTable->SetVtkLookupTable(vtkLUT);
mitk::LookupTableProperty::Pointer LookupTableProp = mitk::LookupTableProperty::New( mitkLookupTable );

result->SetProperty( "LookupTable", LookupTableProp );
result->SetBoolProperty("use color", false);
result->Update();
\endcode
  <li> opacity - Alpha (or transparency) value of the node/image/surface etc.. The
range of the opacity is between 0.0 and 1.0. 

\remark 
If you are inside a mapper you can use the following code to access 
the opacity:
\code
float opacity=1.0f;
GetOpacity( opacity, BaseRenderer );
\endcode
(The BaseRenderer is usually known inside a mapper).


  <li> reslice interpolation - This property takes effect in swivel mode or crosshair rotaiton  only. The interpolation modes "Nearest", "Linear", and "Cubic" are available and  effect the pixel outcome along the rotated plane.
  <li> texture interpolation - This property toggles interpolation of the texture. If enabled, edges between image pixels are blurred. If disabled, edges remain sharp.
  <li> use color - This property toggles the use of a user-defined lookuptable 
for the rendering. True: use the LUT; False: use the color propery.
Example for setting up a lookuptable in MITK:
\code
#include <vtkSmartPointer.h>
#include <vtkLookupTable.h>
#include <mitkLookupTable.h>
#include <mitkLookupTableProperty.h>

[...]

vtkSmartPointer<vtkLookupTable> vtkLUT = vtkSmartPointer<vtkLookupTable>::New();
vtkLUT->SetRange(100,200); //define your table here
vtkLUT->Build();

//pass the table to MITK
mitk::LookupTable::Pointer mitkLookupTable = mitk::LookupTable::New();
mitkLookupTable->SetVtkLookupTable(vtkLUT);
mitk::LookupTableProperty::Pointer LookupTableProp = mitk::LookupTableProperty::New( mitkLookupTable );

result->SetProperty( "LookupTable", LookupTableProp );
result->SetBoolProperty("use color", false);
result->Update();
\endcode
  <li> visible - toggle node/image/surface being rendered at all
</ul>
  
\subsection SurfaceRenderingProperties Surface Rendering Properties

<ul>
  <li> back color - in 2D, color of the normals outside the surface
  <li> back normal lenth (px) - in 2D, length of the normals in pixels 
(When decreasing it the color using the front color is shorter?)
  <li> color mode -  (From VTK) Control how the scalar data is mapped to colors. By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.
  <li> draw normals 2d -  in 2D, toggles the presence of normals
  <li> front color - in 2D, color of the normals inside the surface
  <li> front normal lenth (px) - in 2D, length of the normals in pixels 
(When decreasing it the color using the back color is shorter?)
  <li> invert normals - in 2D, switch front/back normals
  <li> line width - in 2D, controls the thickness of the line where the surface
intersects the plane (and normals)
  <li> material.ambientCoefficient - in 3D ambient lighting
  <li> material.diffuseCoefficient - in 3D scattering of light
  <li> material.interpolation - Choose which interpolation algorithm to use for
surface construction
  <li> material.representation - Choose the representation to draw the mesh in
(Surface, Wireframe, Point Cloud)
  <li> material.specularCoefficient - in-/decrease non-scattered reflection
  <li> material.specularPower - control percentage of non-scattered reflection 
  <li> material.wireframeLineWidth - width of the wires if wireframe representation is
  <li> scalar mode - (From VTK) Control how the filter works with scalar point data and cell attribute data. By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData). If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips, the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip. 
  <li> scalar visibility - (From VTK) Turn on/off flag to control whether scalar data is used to color objects. 
  <li> selected - whether the node is selected
  <li> shader - which shader to use for surface rendering, currently the options are
"fixed" and "mitkShaderLightning"
</ul>

\subsection VolumeRenderingProperties Volume Rendering Properties

<ul>
  <li> TransferFunction - contains transfer function for use in coloring image
  <li> volumerendering -  Should the volume be rendered or not
  <li> volumerendering configuration - Choice between Composite und MIP
  <li> volumerendering.cpu.ambient - ambient lighting
  <li> volumerendering.cpu.diffuse - in-/decrease light dispersion
  <li> volumerendering.cpu.specular - in-/decrease non-scattered reflection
  <li> volumerendering.cpu.specular.power - control percentage of non-scattered
reflection 
  <li> volumerendering.gpu.ambient - same as cpu with gpu
  <li> volumerendering.gpu.diffuse - same as cpu with gpu
  <li> volumerendering.gpu.reducesliceartifacts - Reduce slice artifacts
  <li> volumerendering.gpu.specular - same as cpu with gpu
  <li> volumerendering.gpu.specular.power - same as cpu with gpu
  <li> volumerendering.gpu.usetexturecompression - use texture compression
  <li> volumerendering.ray.ambient - same as cpu with ray
  <li> volumerendering.ray.diffuse - same as cpu with ray
  <li> volumerendering.ray.specular - same as cpu with ray
  <li> volumerendering.ray.specular.power - same as cpu with ray
  <li> volumerendering.usegpu -  Whether to use the GPU for rendering or not
  <li> volumerendering.uselod -  Whether to use the Level Of Detail mechanism or not
  <li> volumerendering.usemip -  Whether to utilize maximum intensity projection
  <li> volumerendering.useray - Whether to use raycasting or not
</ul>
  
\remark
Uselod can be active with usegpu, usemip, useray, but any of the latter can not
be used with another one of them.


\subsection PointSetProperties Point Set Properties

<ul>
  <li> close contour - Toggles whether the first and the last point of a contour
(connecting pieces between following points of a pointset) are connected.
  <li> contourcolor - Determines the color of the contour (connecting pieces between
following points of a pointset). Visible only if "show contour" is active.
  <li> contoursize - Represents the diameter of the contour (which is kind of a tube
between the following points of a pointset). Visible only if "show contour" is
active.
  <li> distance decimal digits - Sets the number of decimal places for the euclidean
point to point distance which can be displayed by activating "show distances". 
  <li> point 2D size - The positions of points in the 2D view are represented by
crosses. "point 2D size" determines the size of this crosses.
  <li> point line width - The positions of points in the 2D view are represented by
crosses. "point line width" determines the thickness of this crosses. 
  <li> pointsize - The positions of points in the 3D view are represented by spheres.
"pointsize" determines the diameter (size) of this spheres.
  <li> selectedcolor - Sets the color for selected points from a pointset.
  <li> show angles - If "show contour" is active the angles between two contour parts
can be shown.
  <li> show contour - Connects following points of a pointset by drawing connecting
pieces between this points.
  <li> show distance lines - Shows all angles and lines of the contour (in 2D views)
even if they are not on the view's current slice.
  <li> show distances - Draws lines between following points (in 2D views) and
displays the euclidean distance between this points.
  <li> show points - Toggles if the points are visible or not in the view.
  <li> updateDataOnRender - If "true" the pointset is updated before rendering. If the
pointset is part of a filter pipeline this also causes an update to the
pipeline which sometimes may be not desired so it can be switched of by setting
it to false.
</ul>

Information on properties not in this list can be found in the appropriate module.

\subsection PropertiesPageSeeAlso See Also

<ul>
 <li> \subpage PlanarPropertiesPage
 <li> \subpage SegmentationPropertiesPage
</ul>
*/
