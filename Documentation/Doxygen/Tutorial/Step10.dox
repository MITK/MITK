/**

\page Step10Page MITK Tutorial - Step 10: Adding new Interaction

\tableofcontents


\section HowToUseDataInteractor How to use an existing DataInteractor

MITK provides finished DataInteractors for a variety of task, they can be found in Code/Core/Interactors. They can be used with
state machine patterns and config files located under Resources/Interaction.


A DataInteractor consists of four parts. The class describing the functionality and two XML files; one describes the state machine pattern, that is the workflow of an interaction and
the second describes the user events which trigger an action. Lastly every DataInteractor works on a DataNode in which it stores and manipulates data.
To use a DataInteractor these parts have to be brought together.


<b>This code demonstrates the use exemplary with the PointSetDataInteractor:</b>

First we need a DataNode that is added to the DataStorage.
\code

  mitk::DataNode::Pointer dataNode = mitk::DataNode::New();
  GetDataStorage()->Add(dataNode.GetPointer());
\endcode

Then we create an instance of to PointSetDataInteractor and load a statemachine pattern as well as a configuration
for it:

\code
  m_CurrentInteractor = mitk::PointSetDataInteractor::New();
  m_CurrentInteractor->LoadStateMachine("PointSet.xml");
  m_CurrentInteractor->AddEventConfig("PointSetConfig.xml");
\endcode

Lastly the DataNode is added to the DataInteractor

\code
  m_CurrentInteractor->SetDataNode(dataNode);
\endcode

now the DataInteractor is ready for usage.

\section SectionImplementationDataInteractor How to implement a new DataInteractor

This tutorial step goes beyond the activation of an interactor , that modifies data by user interaction) as shown above. It shows what needs to be implemented to add a new way of interaction within your MITK application.
Please see \ref DataInteractionPage as an introduction to the MITK interaction mechanism, you may also want to read \ref DataInteractionTechnicalPage.

This tutorial is structured as follows: The first section deals with config files, describing all the parameters of events and how to use them
in a configuration file. In the second section the basics are described that are needed to write a state machine pattern. The last section
deals with brining configuration, state machine pattern and code together and gives an examplary implementation of a DataInteractor.

\section ConfigFileDescriptionSection HowTo Create a Config-File

\subsection EventDescriptionSection Event Description

Events are described by their parameters. Each event type has its own set of parameters that can be set in the configuration file.
If a parameter is ommitted it is set to its default value. Following all possible parameters are listed and described, to which parameters
events have is decribed in their respective documentation.

Mandatory for each event description is the event class and the event variant. The parameters of an event are set by attribute tags.
\note Refer to \ref EventClassSection for the meaning of event class.

\b Modifier \b Keys \n

mitk::ModifierKeys represent the combination of pressed modifier keys, several modifier keys pressed at the same time
are denoted by listing them all separated by commas.

\code
<!-- shift and control key are pressed -->
<attribute name="Modifiers" value="shift,ctrl"/>
\endcode

\b Mouse \b Buttons \n

mitk::MouseButtons represent the buttons. They can be used for two attributes. First the EventButton which describes the button that triggered the event,
this allways is a single button. Secondly the ButtonState attribute that describes which buttons were pressed at the moment the event has been generated.
For example assume the right mouse button and the middle mouse button are already pressed, now also the left mouse button is pressed too and generates a second event,
this would be described as follows:

\code
<attribute name="EventButton" value="LeftMouseButton"/>
<attribute name="ButtonState" value="RightMouseButton,MiddleMouseButton"/>
\endcode

Note: Technically the LeftMouseButton is also pressed and should be listed in the ButtonState, but this is taken care of by the mitk:EventFactory .

\b ScrollDirection \n

This attribute is unique to the mitk::MouseWheelEvent and describes the direction in which the mouse wheel is rotated. In the event description actual only the direction is provided,
but the event is generated with the actual value, and this value can be retrieved from the object.

\code
 <attribute name="ScrollDirection" value="up"/>
 <!-- or -->
 <attribute name="ScrollDirection" value="down"/>
\endcode


\subsection ExamplesSection Examples


Examples for key events:
\code
<config>
  <!-- Event of key 'a' pressed -->
  <input event_class="KeyEvent" event_variant="StdA">
    <attribute name="Key" value="A"/>
  </input>
  <!-- Event of key 'b' pressed  while modifiers ctrl and shift are pressed-->
  <input event_class="KeyEvent" event_variant="StdA">
    <attribute name="Key" value="A"/>
    <attribute name="Modifiers" value="shift,ctrl"/>
  </input>
</config>
\endcode


Examples for MousePress events:
\code
 <!-- Standard left click -->
<config>
  <input event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton">
    <attribute name="EventButton" value="LeftMouseButton"/>
  </input>
<!-- right click with control key pressed-->
  <input event_class="MousePressEvent" event_variant="RightWithCTRL">
    <attribute name="EventButton" value="RightMouseButton"/>
    <attribute name="Modifiers" value="ctrl"/>
  </input>
</config>
\endcode

There exists a standard configuration file for the most common events called GlobalConfig.xml that can be used to as a default and can be extended
by a specific definition.

\subsection ParameterDescriptionSection Parameter Description

It is also possible to store parameters in the config file. Those are stored using the param-tag, like this:

\code
<config name="example2">
 <param name="property1" value="yes"/>
 <param name="scrollModus" value="leftright"/>
</config>
\endcode

Within the application these properties can then be access via a mitk::PropertyList like this:

\code
  // sm - state machine loaded with config file example2

  mitk::PropertyList::Pointer properties = GetPropertyList();
  std::string prop1;
  properties->GetStringProperty("property1",prop1);
\endcode


\section HowToStateMachine HowTo Write a State Machine

A state machine pattern is described in a XML file.

\subsection StateSection States

States are described using the state-tag. Each state has to have a name. Exactly one state has to be as start state in
each state machine to indicate the state in which the state machine is set when it is constructed.
So a valid, but rather useless state machine would like like this:

\code
<statemachine>
 <state name="start" startstate="true"/>
</statemachine>
\endcode

Optionally a state can be assigned a special mode that influences the event distribution.
These modes are GRAB_INPUT , PREFER_INPUT and REGULAR (where REGULAR is default and does not need to be indicated).
See \ref DispatcherEventDistSection for a description of these modes. Use the special modes only when necessary as they prevent other DataInteractors to
receive events.

\code
<!-- example -->
<state name="someState" startstate="true" state_mode="GRAB_INPUT"/>
\endcode

\subsection TransitionSection Transitions
Transitions are part of a state and describe all possible state switches, and are therefore important for modelling an interaction scheme.
Transitions consist a part that describes the event which triggers the transition (event class and event variant) and a target which is state
to which the state machine switches after executing a transition.
An event class describes the event type (see mitk::InteractionEvent for the different classes) and the event variant is a specification thereof
and the exact description is taken from  a config file. Together they determine which event can trigger this transition.
For example this state machine will switch from state A to state B when the StdMousePressPrimaryButton event (left mouse button is pressed) occurs.

\subsubsection EventClassSection Event Class
The event class description supports the polymorphism of the event classes. Therefore state machine patters should be written in the most
general ways possible.
So for a given class hierarchy like this:
\dot
digraph {
  node [shape=record, fontname=Helvetica, fontsize=10];
  a [ label="{PositionEvent}"];
  b [ label="{MousePressEvent}" ];
  c [ label="MouseReleaseEvent" ];
  d [ label="+TouchEvent" ];
  a -> b;
  a -> c;
  a -> d;
}
\enddot

in the state machine pattern the  PositionEvent can be declared as event class to restrict to the events which hold a position information.
The actual implementation is then given in the configuration file. In this case it allows to define event of the classes PositionEvent itself, or
MousePressEvent,MouseReleaseEvent,TouchEvent.
This has the advantage that the patterns remain the same no matter what input devices are used, and the state machine patterns can be configured
for newly added event classes as long as they match the class hierachy (this ensures they hold the neccessary properties).

\code
<statemachine>
 <state name="A" startstate="true">
   <transition event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton" target="B"/>
 <state/>
 <state name="B" />
</statemachine>
\endcode

\subsection ActionSection Actions
Actions can be added to transitions and represent functions in the DataInteractor that are executed on taking a transition.
The following simple state machine will listen for left mouse clicks and execute two actions (and actually never stop).
\code
<statemachine>
    <state name="start" startstate="true">
        <transition event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton" target="start">
            <action name="addPoint"/>
            <action name="countClicks"/>
        </transition>
    </state>
</statemachine>
\endcode

In order to tell the DataInteractor which function to execute these actions are made known to the DataInteractor using
the CONNECT_FUNCTION macro.  This example assumes that there exists an ExampleInteractor which inherits from DataInteractor.
This class implements the functions AddPoint and CountClicks. The actions are introduced by implementing the virtual method
ConnectActionsAndFunctions():

\code
void mitk::ExampleInteractor::ConnectActionsAndFunctions()
{
  CONNECT_FUNCTION("addPoint", AddPoint);
  CONNECT_FUNCTION("countClicks", CountClicks);
}
\endcode

\section HowToDataInteractor Implementation a new DataInteractor

DataInteractors are to inherit from mitk::DataInteractor. Their functionality is implemented in functions that follow this interface:
\code
bool SomeFunctionality(StateMachineAction* , InteractionEvent*);
\endcode

Your functions are connected with actions by implementing the function ConnectActionsAndFunctions(), e.g.

\code
void mitk::ExampleInteractor::ConnectActionsAndFunctions()
{
 CONNECT_FUNCTION("addPoint", AddPoint);
 CONNECT_FUNCTION("enoughPoints", EnoughPoints);
}
\endcode

Now all that is left it to write a state machine pattern and a config file as is described in the tutorials.

\subsection ExampleInternalEvent PointSetDataInteractor
To provide a useful example the mitk::PointSetDataInteractor is annotated with comments that describe the important parts for an implementation
of a DataInteractor.



See \ref PointSet.xml for complete file.




The header file of the DataInteractor looks like this:

\dontinclude mitkPointSetDataInteractor.h

\skipline class MITK_CORE_EXPORT
\until class

\dontinclude mitkPointSetDataInteractor.cpp

The source file looks like this:



Have fun with creating your own interaction and please think about contributing it to MITK!

If you meet any difficulties during this step, don't hesitate to ask on the MITK mailing list mitk-users@lists.sourceforge.net!
People there are kind and will try to help you.


\ref Step09Page "[Previous step]" \ref TutorialPage "[Main tutorial page]"

*/