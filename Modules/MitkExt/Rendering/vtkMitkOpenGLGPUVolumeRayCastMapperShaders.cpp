/*===================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center,
Division of Medical and Biological Informatics.
All rights reserved.

This software is distributed WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

See LICENSE.txt or http://www.mitk.org for details.

===================================================================*/
#include <vtkObject.h>

// Only with VTK 5.6 or above
#if ((VTK_MAJOR_VERSION > 5) || ((VTK_MAJOR_VERSION==5) && (VTK_MINOR_VERSION>=6) ))
                                                                                                                       /* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_CompositeCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_CompositeCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_CompositeCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_CompositeCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some function used by the composite method when cropping\n"
"// is on.\n"
"\n"
"#version 110\n"
"\n"
"// color buffer as an input\n"
"uniform sampler2D frameBufferTexture;\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"vec4 initialColor()\n"
"{\n"
"  return texture2D(frameBufferTexture,fragTexCoord);\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_CompositeFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_CompositeFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_CompositeFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_CompositeFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program part with ray cast and composite method.\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// from cropping vs no cropping\n"
"vec4 initialColor();\n"
"\n"
"// from 1 vs 4 component shader.\n"
"float scalarFromValue(vec4 value);\n"
"vec4 colorFromValue(vec4 value);\n"
"\n"
"// from noshade vs shade.\n"
"void initShade();\n"
"vec4 shade(vec4 value);\n"
"\n"
"void trace(void)\n"
"{\n"
"  vec4 destColor=initialColor();\n"
"  float remainOpacity=1.0-destColor.a;\n"
"\n"
"  bool inside=true;\n"
"  \n"
"  vec4 color;\n"
"  vec4 opacity;\n"
"\n"
"  initShade();\n"
"  \n"
"  float t=0.0;\n"
"  \n"
"  // We NEED two nested while loops. It is trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"\n"
"  while(inside)\n"
"    {  \n"
"    while(inside)\n"
"      {\n"
"      vec4 value=texture3D(dataSetTexture,pos);\n"
"      float scalar=scalarFromValue(value);\n"
"      // opacity is the sampled texture value in the 1D opacity texture at\n"
"      // scalarValue\n"
"      opacity=texture1D(opacityTexture,scalar);\n"
"      if(opacity.a>0.0)\n"
"        {\n"
"        color=shade(value);\n"
"        color=color*opacity.a;\n"
"        destColor=destColor+color*remainOpacity;\n"
"        remainOpacity=remainOpacity*(1.0-opacity.a);\n"
"        }\n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      inside=t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"        && all(lessThanEqual(pos,highBounds))\n"
"        && (remainOpacity>=0.0039); // 1/255=0.0039\n"
"      }\n"
"    }\n"
"  gl_FragColor = destColor;\n"
"  gl_FragColor.a = 1.0-remainOpacity;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_CompositeMaskFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_CompositeMaskFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_CompositeMaskFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_CompositeMaskFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program part with ray cast and composite method with masks.\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler3D maskTexture;\n"
"uniform sampler1D mask1ColorTexture;\n"
"uniform sampler1D mask2ColorTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"uniform float maskBlendFactor;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// from cropping vs no cropping\n"
"vec4 initialColor();\n"
"\n"
"// from 1 vs 4 component shader.\n"
"float scalarFromValue(vec4 value);\n"
"vec4 colorFromValue(vec4 value);\n"
"\n"
"// from noshade vs shade.\n"
"void initShade();\n"
"vec4 shade(vec4 value);\n"
"\n"
"void trace(void)\n"
"{\n"
"  vec4 destColor=initialColor();\n"
"  float remainOpacity=1.0-destColor.a;\n"
"\n"
"  bool inside=true;\n"
"  \n"
"  vec4 maskValue;\n"
"  vec4 color;\n"
"  vec4 opacity;\n"
"\n"
"  initShade();\n"
"  \n"
"  float t=0.0;\n"
"  \n"
"  // We NEED two nested while loops. It is trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"\n"
"  while(inside)\n"
"    {  \n"
"    while(inside)\n"
"      {\n"
"      vec4 value=texture3D(dataSetTexture,pos);\n"
"      float scalar=scalarFromValue(value);\n"
"      opacity=texture1D(opacityTexture,scalar);\n"
"      \n"
"      if(maskBlendFactor==0.0)\n"
"        {\n"
"        color=shade(value);\n"
"        }\n"
"      else\n"
"        {\n"
"        // get the mask value at this same location\n"
"        maskValue=texture3D(maskTexture,pos);\n"
"        if(maskValue.a==0.0)\n"
"          {\n"
"          color=shade(value);\n"
"          }\n"
"        else\n"
"          {\n"
"          if(maskValue.a==1.0/255.0)\n"
"            {\n"
"            color=texture1D(mask1ColorTexture,scalar);\n"
"            }\n"
"          else\n"
"            {\n"
"            // maskValue.a == 2.0/255.0\n"
"            color=texture1D(mask2ColorTexture,scalar);\n"
"            }\n"
"          color.a=1.0;\n"
"          if(maskBlendFactor<1.0)\n"
"            {\n"
"            color=(1.0-maskBlendFactor)*shade(value)+maskBlendFactor*color;\n"
"            }\n"
"//        color.r = 1;\n"
"//        color.g = 0;\n"
"//        color.b = 0;\n"
"//        color.a = 1;\n"
"          }\n"
"        }\n"
"      \n"
"      color=color*opacity.a;\n"
"      destColor=destColor+color*remainOpacity;\n"
"      remainOpacity=remainOpacity*(1.0-opacity.a);\n"
"      \n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      inside=t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"        && all(lessThanEqual(pos,highBounds))\n"
"        && (remainOpacity>=0.0039); // 1/255=0.0039\n"
"      }\n"
"    }\n"
"  gl_FragColor = destColor;\n"
"  gl_FragColor.a = 1.0-remainOpacity;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_CompositeNoCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_CompositeNoCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_CompositeNoCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_CompositeNoCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some function used by the composite method when cropping\n"
"// is off.\n"
"\n"
"#version 110\n"
"\n"
"// Max intensity is the lowest value.\n"
"vec4 initialColor()\n"
"{\n"
"  return vec4(0.0,0.0,0.0,0.0);\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the Minimum Intensity Projection\n"
"// (MinIP) method when cropping is on.\n"
"\n"
"#version 110\n"
"\n"
"// GLSL Spec 1.10 rev 59 30-April-2004 defines gl_FragData[] but implementation\n"
"// older than the spec only has it as an extension\n"
"// (nVidia Linux driver 100.14.13, OpenGL version 2.1.1,\n"
"// on Quadro FX 3500/PCI/SSE2)\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"// max scalar buffer as an input\n"
"uniform sampler2D scalarBufferTexture;\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the scalar frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"float initialMinValue()\n"
"{\n"
"  return texture2D(scalarBufferTexture,fragTexCoord).r;\n"
"}\n"
"\n"
"void writeColorAndMinScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float minValue)\n"
"{\n"
"  // color framebuffer\n"
"  gl_FragData[0].r =sample.r * opacity.a;\n"
"  gl_FragData[0].g =sample.g * opacity.a;\n"
"  gl_FragData[0].b =sample.b * opacity.a;\n"
"  gl_FragData[0].a=opacity.a;\n"
"  \n"
"  // min scalar framebuffer\n"
"  gl_FragData[1].r=minValue;\n"
"  gl_FragData[1].g=0.0;\n"
"  gl_FragData[1].b=0.0;\n"
"  gl_FragData[1].a=0.0;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the 4-component Minimum Intensity\n"
"// Projection (MinIP) method when cropping is on.\n"
"\n"
"#version 110\n"
"\n"
"// GLSL Spec 1.10 rev 59 30-April-2004 defines gl_FragData[] but implementation\n"
"// older than the spec only has it as an extension\n"
"// (nVidia Linux driver 100.14.13, OpenGL version 2.1.1,\n"
"// on Quadro FX 3500/PCI/SSE2)\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"// max scalar buffer as an input\n"
"uniform sampler2D scalarBufferTexture;\n"
"\n"
"// color buffer as an input\n"
"uniform sampler2D frameBufferTexture;\n"
"\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the scalar frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"float initialMinValue()\n"
"{\n"
"  return texture2D(scalarBufferTexture,fragTexCoord).r;\n"
"}\n"
"\n"
"vec4 initialColor()\n"
"{\n"
"  return texture2D(frameBufferTexture,fragTexCoord);\n"
"}\n"
"\n"
"void writeColorAndMinScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float minValue)\n"
"{\n"
"  // color framebuffer\n"
"  gl_FragData[0].r = color.r*opacity.a;\n"
"  gl_FragData[0].g = color.g*opacity.a;\n"
"  gl_FragData[0].b = color.b*opacity.a;\n"
"  gl_FragData[0].a=opacity.a;\n"
"  \n"
"  // min scalar framebuffer\n"
"  gl_FragData[1].r=minValue;\n"
"  gl_FragData[1].g=0.0;\n"
"  gl_FragData[1].b=0.0;\n"
"  gl_FragData[1].a=0.0;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program with ray cast and 4-dependent-component Minimum Intensity\n"
"// Projection (MinIP) method.\n"
"// Compilation: header part and the projection part are inserted first.\n"
"// pos is defined and initialized in header\n"
"// rayDir is defined in header and initialized in the projection part\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// Sub-functions, depending on cropping mode\n"
"float initialMinValue();\n"
"vec4 initialColor();\n"
"void writeColorAndMinScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float minValue);\n"
"\n"
"void trace(void)\n"
"{\n"
"  // Max intensity is the lowest value.\n"
"  float minValue=initialMinValue();\n"
"  vec4 color=initialColor();\n"
"  bool inside=true;\n"
"  float t=0.0;\n"
"  vec4 sample;\n"
"  bool changed=false;\n"
"  \n"
"  // We NEED two nested while loops. It is a trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"  while(inside)\n"
"    {\n"
"    while(inside)\n"
"      {\n"
"      sample=texture3D(dataSetTexture,pos);\n"
"      if(sample.w<minValue)\n"
"        {\n"
"        changed=true;\n"
"        minValue=sample.w;\n"
"        color=sample;\n"
"        }\n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      \n"
"      // yes, t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"      // && all(lessThanEqual(pos,highBounds));\n"
"      // looks better but the latest nVidia 177.80 has a bug...\n"
"      inside=t<tMax && pos.x>=lowBounds.x && pos.y>=lowBounds.y\n"
"        && pos.z>=lowBounds.z && pos.x<=highBounds.x && pos.y<=highBounds.y\n"
"        && pos.z<=highBounds.z;\n"
"      }\n"
"    }\n"
"  \n"
"  if(changed)\n"
"    {\n"
"    vec4 opacity=texture1D(opacityTexture,minValue);\n"
"    writeColorAndMinScalar(color,opacity,minValue);\n"
"    }\n"
"  else\n"
"    {\n"
"    discard;\n"
"    }\n"
"}\n"
"\n";


/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentNoCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentNoCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentNoCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPFourDependentNoCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the 4-component Minimum Intensity\n"
"// Projection (MinIP) method when cropping is off.\n"
"\n"
"#version 110\n"
"\n"
"float initialMinValue()\n"
"{\n"
"  return 1.0;\n"
"}\n"
"\n"
"vec4 initialColor()\n"
"{\n"
"  return vec4(0.0,0.0,0.0,0.0);\n"
"}\n"
"\n"
"void writeColorAndMinScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float minValue)\n"
"{\n"
"  // minValue is not used\n"
"  \n"
"  // color framebuffer\n"
"  gl_FragColor.r = color.r*opacity.a;\n"
"  gl_FragColor.g = color.g*opacity.a;\n"
"  gl_FragColor.b = color.b*opacity.a;\n"
"  gl_FragColor.a=opacity.a;\n"
"}\n"
"\n";


/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program with ray cast and Minimum Intensity Projection (MinIP)\n"
"// method.\n"
"// Compilation: header part and the projection part are inserted first.\n"
"// pos is defined and initialized in header\n"
"// rayDir is defined in header and initialized in the projection part\n"
"// initMinValue() and writeColorAndMinScalar are defined in some specific\n"
"// file depending on cropping flag being on or off.\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler1D colorTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// Sub-functions, depending on cropping mode\n"
"float initialMinValue();\n"
"void writeColorAndMinScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float minValue);\n"
"\n"
"void trace(void)\n"
"{\n"
"  // Max intensity is the lowest value.\n"
"  float minValue=initialMinValue();\n"
"  bool inside=true;\n"
"  vec4 sample;\n"
"  \n"
"  float t=0.0;\n"
"  // We NEED two nested while loops. It is trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"  while(inside)\n"
"    {\n"
"    while(inside)\n"
"      {\n"
"      sample=texture3D(dataSetTexture,pos);\n"
"      minValue=min(minValue,sample.r);\n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      inside=t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"        && all(lessThanEqual(pos,highBounds));\n"
"      \n"
"      // yes, t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"      // && all(lessThanEqual(pos,highBounds));\n"
"      // looks better but the latest nVidia 177.80 has a bug...\n"
"      inside=t<tMax && pos.x>=lowBounds.x && pos.y>=lowBounds.y\n"
"        && pos.z>=lowBounds.z && pos.x<=highBounds.x && pos.y<=highBounds.y\n"
"        && pos.z<=highBounds.z;\n"
"      \n"
"      \n"
"      }\n"
"    }\n"
"\n"
"  sample=texture1D(colorTexture,minValue);\n"
"  vec4 opacity=texture1D(opacityTexture,minValue);\n"
"  \n"
"  writeColorAndMinScalar(sample,opacity,minValue);\n"
"}\n"
"\n";


/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MinIPNoCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MinIPNoCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MinIPNoCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MinIPNoCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the Minimum Intensity projection\n"
"// (MinIP) method when cropping is off.\n"
"\n"
"#version 110\n"
"\n"
"float initialMinValue()\n"
"{\n"
"  return 1.0;\n"
"}\n"
"\n"
"void writeColorAndMinScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float minValue)\n"
"{\n"
"  // we don't need to write minValue to a buffer when there is no cropping.\n"
"  // color framebuffer\n"
"  gl_FragColor.r =sample.r * opacity.a;\n"
"  gl_FragColor.g =sample.g * opacity.a;\n"
"  gl_FragColor.b =sample.b * opacity.a;\n"
"  gl_FragColor.a=opacity.a;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the Maximum Intensity Projection\n"
"// (MIP) method when cropping is on.\n"
"\n"
"#version 110\n"
"\n"
"// GLSL Spec 1.10 rev 59 30-April-2004 defines gl_FragData[] but implementation\n"
"// older than the spec only has it as an extension\n"
"// (nVidia Linux driver 100.14.13, OpenGL version 2.1.1,\n"
"// on Quadro FX 3500/PCI/SSE2)\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"// max scalar buffer as an input\n"
"uniform sampler2D scalarBufferTexture;\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the scalar frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"float initialMaxValue()\n"
"{\n"
"  return texture2D(scalarBufferTexture,fragTexCoord).r;\n"
"}\n"
"\n"
"void writeColorAndMaxScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float maxValue)\n"
"{\n"
"  // color framebuffer\n"
"  gl_FragData[0].r =sample.r * opacity.a;\n"
"  gl_FragData[0].g =sample.g * opacity.a;\n"
"  gl_FragData[0].b =sample.b * opacity.a;\n"
"  gl_FragData[0].a=opacity.a;\n"
"  \n"
"  // max scalar framebuffer\n"
"  gl_FragData[1].r=maxValue;\n"
"  gl_FragData[1].g=0.0;\n"
"  gl_FragData[1].b=0.0;\n"
"  gl_FragData[1].a=0.0;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPFourDependentCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPFourDependentCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPFourDependentCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPFourDependentCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the 4-component Maximum Intensity\n"
"// Projection (MIP) method when cropping is on.\n"
"\n"
"#version 110\n"
"\n"
"// GLSL Spec 1.10 rev 59 30-April-2004 defines gl_FragData[] but implementation\n"
"// older than the spec only has it as an extension\n"
"// (nVidia Linux driver 100.14.13, OpenGL version 2.1.1,\n"
"// on Quadro FX 3500/PCI/SSE2)\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"// max scalar buffer as an input\n"
"uniform sampler2D scalarBufferTexture;\n"
"\n"
"// color buffer as an input\n"
"uniform sampler2D frameBufferTexture;\n"
"\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the scalar frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"float initialMaxValue()\n"
"{\n"
"  return texture2D(scalarBufferTexture,fragTexCoord).r;\n"
"}\n"
"\n"
"vec4 initialColor()\n"
"{\n"
"  return texture2D(frameBufferTexture,fragTexCoord);\n"
"}\n"
"\n"
"void writeColorAndMaxScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float maxValue)\n"
"{\n"
"  // color framebuffer\n"
"  gl_FragData[0].r = color.r*opacity.a;\n"
"  gl_FragData[0].g = color.g*opacity.a;\n"
"  gl_FragData[0].b = color.b*opacity.a;\n"
"  gl_FragData[0].a=opacity.a;\n"
"  \n"
"  // max scalar framebuffer\n"
"  gl_FragData[1].r=maxValue;\n"
"  gl_FragData[1].g=0.0;\n"
"  gl_FragData[1].b=0.0;\n"
"  gl_FragData[1].a=0.0;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPFourDependentFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPFourDependentFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPFourDependentFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPFourDependentFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program with ray cast and 4-dependent-component Maximum Intensity\n"
"// Projection (MIP) method.\n"
"// Compilation: header part and the projection part are inserted first.\n"
"// pos is defined and initialized in header\n"
"// rayDir is defined in header and initialized in the projection part\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// Sub-functions, depending on cropping mode\n"
"float initialMaxValue();\n"
"vec4 initialColor();\n"
"void writeColorAndMaxScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float maxValue);\n"
"\n"
"void trace(void)\n"
"{\n"
"  // Max intensity is the lowest value.\n"
"  float maxValue=initialMaxValue();\n"
"  vec4 color=initialColor();\n"
"  bool inside=true;\n"
"  float t=0.0;\n"
"  vec4 sample;\n"
"  bool changed=false;\n"
"  \n"
"  // We NEED two nested while loops. It is a trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"  while(inside)\n"
"    {\n"
"    while(inside)\n"
"      {\n"
"      sample=texture3D(dataSetTexture,pos);\n"
"      if(sample.w>maxValue)\n"
"        {\n"
"        changed=true;\n"
"        maxValue=sample.w;\n"
"        color=sample;\n"
"        }\n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      \n"
"      // yes, t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"      // && all(lessThanEqual(pos,highBounds));\n"
"      // looks better but the latest nVidia 177.80 has a bug...\n"
"      inside=t<tMax && pos.x>=lowBounds.x && pos.y>=lowBounds.y\n"
"        && pos.z>=lowBounds.z && pos.x<=highBounds.x && pos.y<=highBounds.y\n"
"        && pos.z<=highBounds.z;\n"
"      }\n"
"    }\n"
"  \n"
"  if(changed)\n"
"    {\n"
"    vec4 opacity=texture1D(opacityTexture,maxValue);\n"
"    writeColorAndMaxScalar(color,opacity,maxValue);\n"
"    }\n"
"  else\n"
"    {\n"
"    discard;\n"
"    }\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPFourDependentNoCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPFourDependentNoCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPFourDependentNoCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPFourDependentNoCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the 4-component Maximum Intensity\n"
"// Projection (MIP) method when cropping is off.\n"
"\n"
"#version 110\n"
"\n"
"float initialMaxValue()\n"
"{\n"
"  return 0.0;\n"
"}\n"
"\n"
"vec4 initialColor()\n"
"{\n"
"  return vec4(0.0,0.0,0.0,0.0);\n"
"}\n"
"\n"
"void writeColorAndMaxScalar(vec4 color,\n"
"                            vec4 opacity,\n"
"                            float maxValue)\n"
"{\n"
"  // maxValue is not used\n"
"  \n"
"  // color framebuffer\n"
"  gl_FragColor.r = color.r*opacity.a;\n"
"  gl_FragColor.g = color.g*opacity.a;\n"
"  gl_FragColor.b = color.b*opacity.a;\n"
"  gl_FragColor.a=opacity.a;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment program with ray cast and Maximum Intensity Projection (MIP)\n"
"// method.\n"
"// Compilation: header part and the projection part are inserted first.\n"
"// pos is defined and initialized in header\n"
"// rayDir is defined in header and initialized in the projection part\n"
"// initMaxValue() and writeColorAndMaxScalar are defined in some specific\n"
"// file depending on cropping flag being on or off.\n"
"\n"
"#version 110\n"
"\n"
"uniform sampler3D dataSetTexture;\n"
"uniform sampler1D colorTexture;\n"
"uniform sampler1D opacityTexture;\n"
"\n"
"uniform vec3 lowBounds;\n"
"uniform vec3 highBounds;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"float tMax;\n"
"\n"
"// Sub-functions, depending on cropping mode\n"
"float initialMaxValue();\n"
"void writeColorAndMaxScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float maxValue);\n"
"\n"
"void trace(void)\n"
"{\n"
"  // Max intensity is the lowest value.\n"
"  float maxValue=initialMaxValue();\n"
"  bool inside=true;\n"
"  vec4 sample;\n"
"  \n"
"  float t=0.0;\n"
"  // We NEED two nested while loops. It is trick to work around hardware\n"
"  // limitation about the maximum number of loops.\n"
"  while(inside)\n"
"    {\n"
"    while(inside)\n"
"      {\n"
"      sample=texture3D(dataSetTexture,pos);\n"
"      maxValue=max(maxValue,sample.r);\n"
"      pos=pos+rayDir;\n"
"      t+=1.0;\n"
"      \n"
"      // yes, t<tMax && all(greaterThanEqual(pos,lowBounds))\n"
"      // && all(lessThanEqual(pos,highBounds));\n"
"      // looks better but the latest nVidia 177.80 has a bug...\n"
"      inside=t<tMax && pos.x>=lowBounds.x && pos.y>=lowBounds.y\n"
"        && pos.z>=lowBounds.z && pos.x<=highBounds.x && pos.y<=highBounds.y\n"
"        && pos.z<=highBounds.z;\n"
"      }\n"
"    }\n"
"\n"
"  sample=texture1D(colorTexture,maxValue);\n"
"  vec4 opacity=texture1D(opacityTexture,maxValue);\n"
"  \n"
"  writeColorAndMaxScalar(sample,opacity,maxValue);\n"
"}\n"
"\n";


/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_MIPNoCroppingFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_MIPNoCroppingFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_MIPNoCroppingFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_MIPNoCroppingFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Implementation of some functions used by the Maximum Intensity projection\n"
"// (MIP) method when cropping is off.\n"
"\n"
"#version 110\n"
"\n"
"float initialMaxValue()\n"
"{\n"
"  return 0.0;\n"
"}\n"
"\n"
"void writeColorAndMaxScalar(vec4 sample,\n"
"                            vec4 opacity,\n"
"                            float maxValue)\n"
"{\n"
"  // we don't need to write maxValue to a buffer when there is no cropping.\n"
"  // color framebuffer\n"
"  gl_FragColor.r =sample.r * opacity.a;\n"
"  gl_FragColor.g =sample.g * opacity.a;\n"
"  gl_FragColor.b =sample.b * opacity.a;\n"
"  gl_FragColor.a=opacity.a;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_OneComponentFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_OneComponentFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_OneComponentFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_OneComponentFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment shader that implements scalarFromValue() and colorFromValue() in\n"
"// the case of a one-component dataset.\n"
"// The functions are used in composite mode.\n"
"\n"
"#version 110\n"
"\n"
"// \"value\" is a sample of the dataset.\n"
"// Think of \"value\" as an object.\n"
"\n"
"uniform sampler1D colorTexture;\n"
"\n"
"float scalarFromValue(vec4 value)\n"
"{\n"
"  return value.x;\n"
"}\n"
"\n"
"vec4 colorFromValue(vec4 value)\n"
"{\n"
"  return texture1D(colorTexture,value.x);\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_ParallelProjectionFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_ParallelProjectionFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_ParallelProjectionFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_ParallelProjectionFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Parallel projection.\n"
"\n"
"#version 110\n"
"\n"
"uniform vec3 parallelRayDirection;\n"
"\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"// Defined in the right projection method.\n"
"void incrementalRayDirection()\n"
"{\n"
"  rayDir=parallelRayDirection;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_PerspectiveProjectionFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_PerspectiveProjectionFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_PerspectiveProjectionFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_PerspectiveProjectionFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Perspective projection.\n"
"\n"
"#version 110\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"// Camera position in texture space\n"
"uniform vec3 cameraPosition;\n"
"// Sample distance in world space\n"
"uniform float sampleDistance;\n"
"// Matrix coefficients: diagonal (a11,a22,a33)\n"
"uniform vec3 matrix1;\n"
"// Matrix coefficients: others (2a12,2a23,2a13)\n"
"uniform vec3 matrix2;\n"
"\n"
"// Defined in the right projection method.\n"
"void incrementalRayDirection()\n"
"{\n"
"  // Direction of the ray in texture space, not normalized.\n"
"  rayDir=pos-cameraPosition;\n"
"  \n"
"  // x^2, y^2, z^2\n"
"  vec3 normDir=rayDir*rayDir;\n"
"  normDir.x=dot(normDir,matrix1);\n"
"  \n"
"  // xy,yz,zx\n"
"  vec3 coefs=rayDir*rayDir.yxz;\n"
"  coefs.x=dot(coefs,matrix2);\n"
"\n"
"  // n^2\n"
"  normDir.x=normDir.x+coefs.x;\n"
"  \n"
"  // 1/n\n"
"  // normDir=1/sqrt(normDir)\n"
"  normDir.x=inversesqrt(normDir.x);\n"
"  \n"
"  // Final scale factor for the ray direction in texture space\n"
"  // normDir=normDir*sampleDistance\n"
"  normDir.x=normDir.x*sampleDistance;\n"
"  // Now, rayDir is the incremental direction in texture space\n"
"  rayDir=rayDir*normDir.x;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_ScaleBiasFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_ScaleBiasFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_ScaleBiasFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_ScaleBiasFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// This fragment shader scales and biases a framebuffer passed as a texture.\n"
"// Incoming color from the texture is pre-multiplied by alpha.\n"
"// It does not affect the alpha component.\n"
"// Passing the framebuffer as a texture allows the use of a reduction factor\n"
"// compared to the size of the final image.\n"
"\n"
"#version 110\n"
"\n"
"// Framebuffer to scale.\n"
"uniform sampler2D frameBufferTexture;\n"
"uniform float scale;\n"
"uniform float bias;\n"
"\n"
"void main()\n"
"{\n"
"  vec4 color=texture2D(frameBufferTexture,gl_TexCoord[0].xy);\n"
"  if(color.a==0.0)\n"
"    {\n"
"    discard;\n"
"    }\n"
"  // As incoming color is pre-multiplied by alpha, the bias has to be\n"
"  // multiplied by alpha before adding it.\n"
"  gl_FragColor.r=color.r*scale+bias*color.a;\n"
"  gl_FragColor.g=color.g*scale+bias*color.a;\n"
"  gl_FragColor.b=color.b*scale+bias*color.a;\n"
"  gl_FragColor.a=color.a;\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_ShadeFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_ShadeFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_ShadeFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_ShadeFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"// Fragment shader that implements initShade() and shade() in the case of\n"
"// shading.\n"
"// The functions are used in composite mode.\n"
"\n"
"#version 110\n"
"\n"
"// \"value\" is a sample of the dataset.\n"
"// Think of \"value\" as an object.\n"
"\n"
"// from 1- vs 4-component shader.\n"
"vec4 colorFromValue(vec4 value);\n"
"\n"
"uniform sampler3D dataSetTexture; // need neighbors for gradient\n"
"\n"
"// Change-of-coordinate matrix from eye space to texture space\n"
"uniform mat3 eyeToTexture3;\n"
"uniform mat4 eyeToTexture4;\n"
"\n"
"// Tranpose of Change-of-coordinate matrix from texture space to eye space\n"
"uniform mat3 transposeTextureToEye;\n"
"\n"
"// Used to compute the gradient.\n"
"uniform vec3 cellStep;\n"
"uniform vec3 cellScale;\n"
"\n"
"\n"
"// Entry position (global scope), updated in the loop\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"\n"
"// local to the implementation, shared between initShade() and shade()\n"
"const vec3 minusOne=vec3(-1.0,-1.0,-1.0);\n"
"const vec4 clampMin=vec4(0.0,0.0,0.0,0.0);\n"
"const vec4 clampMax=vec4(1.0,1.0,1.0,1.0);\n"
"\n"
"vec3 xvec;\n"
"vec3 yvec;\n"
"vec3 zvec;\n"
"vec3 wReverseRayDir;\n"
"vec3 lightPos;\n"
"vec3 ldir;\n"
"vec3 h;\n"
"vec4 hPos; // homogeneous position\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"void initShade()\n"
"{\n"
"  xvec=vec3(cellStep.x,0.0,0.0); // 0.01\n"
"  yvec=vec3(0.0,cellStep.y,0.0);\n"
"  zvec=vec3(0.0,0.0,cellStep.z);\n"
"  \n"
"  // Reverse ray direction in eye space\n"
"  wReverseRayDir=eyeToTexture3*rayDir;\n"
"  wReverseRayDir=wReverseRayDir*minusOne;\n"
"  wReverseRayDir=normalize(wReverseRayDir);\n"
"  \n"
"  // Directonal light: w==0\n"
"  if(gl_LightSource[0].position.w==0.0)\n"
"    {\n"
"    ldir=gl_LightSource[0].position.xyz;\n"
"    ldir=normalize(ldir);\n"
"    h=normalize(ldir+wReverseRayDir);\n"
"    }\n"
"  else\n"
"    {\n"
"    lightPos=gl_LightSource[0].position.xyz/gl_LightSource[0].position.w;\n"
"    hPos.w=1.0; // used later\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"vec4 shade(vec4 value)\n"
"{\n"
"  vec3 g1;\n"
"  vec3 g2;\n"
"  vec4 tmp;\n"
"  float att;\n"
"  float spot;\n"
"  \n"
"  g1.x=texture3D(dataSetTexture,pos+xvec).x;\n"
"  g1.y=texture3D(dataSetTexture,pos+yvec).x;\n"
"  g1.z=texture3D(dataSetTexture,pos+zvec).x;\n"
"  g2.x=texture3D(dataSetTexture,pos-xvec).x;\n"
"  g2.y=texture3D(dataSetTexture,pos-yvec).x;\n"
"  g2.z=texture3D(dataSetTexture,pos-zvec).x;\n"
"  // g1-g2 is  the gradient in texture coordinates\n"
"  // the result is the normalized gradient in eye coordinates.\n"
"  \n"
"  g2=g1-g2;\n"
"  g2=g2*cellScale;\n"
"  \n"
"  float normalLength=length(g2);\n"
"  if(normalLength>0.0)\n"
"    {\n"
"    g2=normalize(transposeTextureToEye*g2);\n"
"    }\n"
"  else\n"
"    {\n"
"    g2=vec3(0.0,0.0,0.0);\n"
"    }\n"
"  \n"
"  vec4 color=colorFromValue(value);\n"
"  \n"
"  // initialize color to 0.0\n"
"  vec4 finalColor=vec4(0.0,0.0,0.0,0.0);        \n"
"  \n"
"  if(gl_LightSource[0].position.w!=0.0)\n"
"    {\n"
"    // We need to know the eye position only if light is positional\n"
"    // ldir= vertex position in eye coordinates\n"
"    hPos.xyz=pos;\n"
"    tmp=eyeToTexture4*hPos;\n"
"    ldir=tmp.xyz/tmp.w;\n"
"    // ldir=light direction\n"
"    ldir=lightPos-ldir;\n"
"    float sqrDistance=dot(ldir,ldir);\n"
"    ldir=normalize(ldir);\n"
"    h=normalize(ldir+wReverseRayDir);\n"
"    att=1.0/(gl_LightSource[0].constantAttenuation+gl_LightSource[0].linearAttenuation*sqrt(sqrDistance)+gl_LightSource[0].quadraticAttenuation*sqrDistance);\n"
"    }\n"
"  else\n"
"    {\n"
"    att=1.0;\n"
"    }\n"
"  \n"
"  if(att>0.0)\n"
"    {\n"
"    if(gl_LightSource[0].spotCutoff==180.0)\n"
"      {\n"
"      spot=1.0;\n"
"      }\n"
"    else\n"
"      {\n"
"      float coef=-dot(ldir,gl_LightSource[0].spotDirection);\n"
"      if(coef>=gl_LightSource[0].spotCosCutoff)\n"
"        {\n"
"        spot=pow(coef,gl_LightSource[0].spotExponent);\n"
"        }\n"
"      else\n"
"        {\n"
"        spot=0.0;\n"
"        }\n"
"      }\n"
"    if(spot>0.0)\n"
"      {\n"
"      // LIT operation...\n"
"      float nDotL=dot(g2,ldir);\n"
"      float nDotH=dot(g2,h);\n"
"      \n"
"      // separate nDotL and nDotH for two-sided shading, otherwise we\n"
"      // get black spots.\n"
"      \n"
"      if(nDotL<0.0) // two-sided shading\n"
"        {\n"
"        nDotL=-nDotL;\n"
"        }\n"
"      \n"
"      if(nDotH<0.0) // two-sided shading\n"
"        {\n"
"        nDotH=-nDotH;\n"
"        }\n"
"      // ambient term for this light\n"
"      finalColor+=gl_FrontLightProduct[0].ambient;\n"
"      \n"
"      // diffuse term for this light\n"
"      if(nDotL>0.0)\n"
"        {\n"
// WORKAROUND FIX: gl_FrontLightProduct[0].diffuse seems to be not transferred to ATI cards
//"        finalColor+=(gl_FrontLightProduct[0].diffuse*nDotL)*color;\n"
// just using a white light now
"        finalColor+=(0.8*nDotL)*color;\n"
"        }\n"
"      \n"
"      // specular term for this light\n"
"      float shininessFactor=pow(nDotH,gl_FrontMaterial.shininess);\n"
"      finalColor+=gl_FrontLightProduct[0].specular*shininessFactor;\n"
"      finalColor*=att*spot;\n"
"      }\n"
"    }\n"
"  \n"
"  // scene ambient term\n"
// WORKAROUND FIX: gl_FrontLightModelProduct.sceneColor seems to be not transferred to ATI cards
//"  finalColor+=gl_FrontLightModelProduct.sceneColor*color;\n"
// just using a dim ambient light
"  finalColor+=0.3*color;\n"
"  \n"
"  // clamp. otherwise we get black spots\n"
"  finalColor=clamp(finalColor,clampMin,clampMax);\n"
"  \n"
"  return finalColor;\n"
"}\n"
"\n";




/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_NoShadeFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_NoShadeFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_NoShadeFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_NoShadeFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment shader that implements initShade() and shade() in the case of no\n"
"// shading.\n"
"// The functions are used in composite mode.\n"
"\n"
"#version 110\n"
"\n"
"// \"value\" is a sample of the dataset.\n"
"// Think of \"value\" as an object.\n"
"\n"
"// from 1- vs 4-component shader.\n"
"vec4 colorFromValue(vec4 value);\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"void initShade()\n"
"{\n"
"  // empty, nothing to do.\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"vec4 shade(vec4 value)\n"
"{\n"
"  return colorFromValue(value);\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_HeaderFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_HeaderFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_HeaderFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_HeaderFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"#version 110\n"
"\n"
"// Depth map of the polygonal geometry\n"
"uniform sampler2D depthTexture;\n"
"\n"
"// 2D noise texture to jitter the starting point of the ray in order to\n"
"// remove patterns when the opacity transfer function make the data on the\n"
"// border of the dataset to be visible.\n"
"uniform sampler2D noiseTexture;\n"
"\n"
"uniform vec2 windowLowerLeftCorner;\n"
"uniform vec2 invOriginalWindowSize;\n"
"uniform vec2 invWindowSize;\n"
"\n"
"// Change-of-coordinate matrix from eye space to texture space\n"
"uniform mat4 textureToEye;\n"
"\n"
"// Entry position (global scope)\n"
"vec3 pos;\n"
"// Incremental vector in texture space (global scope)\n"
"vec3 rayDir;\n"
"\n"
"// Abscissa along the ray of the point on the depth map\n"
"// tracing stops when t>=tMax\n"
"float tMax;\n"
"\n"
"// 2D Texture fragment coordinates [0,1] from fragment coordinates\n"
"// the frame buffer texture has the size of the plain buffer but\n"
"// we use a fraction of it. The texture coordinates is less than 1 if\n"
"// the reduction factor is less than 1.\n"
"vec2 fragTexCoord;\n"
"\n"
"// Defined in the right projection method.\n"
"// May use pos in global scope as input.\n"
"// Use rayDir in global scope as output.\n"
"void incrementalRayDirection();\n"
"void trace();\n"
"\n"
"void main()\n"
"{\n"
"\n"
"  // device coordinates are between -1 and 1\n"
"  // we need texture coordinates between 0 and 1\n"
"  // the depth buffer has the original size buffer.\n"
"  fragTexCoord=(gl_FragCoord.xy-windowLowerLeftCorner)*invWindowSize;\n"
"  vec4 depth=texture2D(depthTexture,fragTexCoord);\n"
"  if(gl_FragCoord.z>=depth.x) // depth test\n"
"    {\n"
"    discard;\n"
"    }\n"
"  \n"
"  // color buffer or max scalar buffer have a reduced size.\n"
"  fragTexCoord=(gl_FragCoord.xy-windowLowerLeftCorner)*invOriginalWindowSize;\n"
"  // Abscissa of the point on the depth buffer along the ray.\n"
"  // point in texture coordinates\n"
"  vec4 maxPoint;\n"
"  \n"
"  // from window coordinates to normalized device coordinates\n"
"  maxPoint.x=(gl_FragCoord.x-windowLowerLeftCorner.x)*2.0*invWindowSize.x-1.0;\n"
"  maxPoint.y=(gl_FragCoord.y-windowLowerLeftCorner.y)*2.0*invWindowSize.y-1.0;\n"
"  maxPoint.z=(2.0*depth.x-(gl_DepthRange.near+gl_DepthRange.far))/gl_DepthRange.diff;\n"
"  maxPoint.w=1.0;\n"
"  \n"
"  // from normalized device coordinates to eye coordinates\n"
"  maxPoint=gl_ProjectionMatrixInverse*maxPoint;\n"
"  \n"
"  // from eye coordinates to texture coordinates\n"
"  maxPoint=textureToEye*maxPoint;\n"
"  // homogeneous to cartesian coordinates\n"
"  maxPoint/=maxPoint.w;\n"
"  \n"
"  // Entry position. divide by q.\n"
"  // pos=gl_TexCoord[0].xyz/gl_TexCoord[0].w;\n"
"  \n"
"  pos.x=gl_TexCoord[0].x/gl_TexCoord[0].w;\n"
"  pos.y=gl_TexCoord[0].y/gl_TexCoord[0].w;\n"
"  pos.z=gl_TexCoord[0].z/gl_TexCoord[0].w;\n"
"  \n"
"  // Incremental vector in texture space. Computation depends on the\n"
"  // type of projection (parallel or perspective)\n"
"  incrementalRayDirection();\n"
"  \n"
"  vec4 noiseValue=texture2D(noiseTexture,pos.xy*100.0); // with repeat/tiling mode on the noise texture.\n"
"  \n"
"  pos+=(noiseValue.x)*rayDir;\n"
"\n"
"  tMax=length(maxPoint.xyz-pos.xyz) /length(rayDir);\n"
"\n"
"\n"
"  // Tracing method. Set the final fragment color.\n"
"  trace();\n"
"}\n"
"\n";

/* DO NOT EDIT.
 * Generated by ..\bin\Release\vtkEncodeString.exe
 *
 * Define the vtkMitkGPUVolumeRayCastMapper_FourComponentsFS string.
 *
 * Generated from file: V:/windows/source/VTK560/VolumeRendering/vtkMitkGPUVolumeRayCastMapper_FourComponentsFS.glsl
 */
const char *vtkMitkGPUVolumeRayCastMapper_FourComponentsFS =
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    $RCSfile: vtkMitkGPUVolumeRayCastMapper_FourComponentsFS.glsl,v $\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"// Fragment shader that implements scalarFromValue() and colorFromValue() in\n"
"// the case of a one-component dataset.\n"
"// The functions are used in composite mode.\n"
"\n"
"#version 110\n"
"\n"
"// \"value\" is a sample of the dataset.\n"
"// Think of \"value\" as an object.\n"
"\n"
"float scalarFromValue(vec4 value)\n"
"{\n"
"  return value.w;\n"
"}\n"
"\n"
"vec4 colorFromValue(vec4 value)\n"
"{\n"
"  return vec4(value.xyz,1.0);\n"
"}\n"
"\n";

#endif
